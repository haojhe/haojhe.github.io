<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深度需求分析</title>
    <url>/2021/07/15/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="软件需求工程"><a href="#软件需求工程" class="headerlink" title="软件需求工程"></a>软件需求工程</h1><p>指在工程设计过程中定义、记录和维护需求的过程。首先要需求工程范畴：<br><img src="/2021/07/15/项目管理/软件需求工程.png" alt="需求工程范畴"></p>
<ul>
<li>需求开发工作要点<br>通过需求获取、需求分析、编写规约和需求验证4个具体活动多次循环的形式进行需求开发。</li>
</ul>
<h1 id="login-BDD-Example"><a href="#login-BDD-Example" class="headerlink" title="login BDD Example"></a>login BDD Example</h1><p>BDD是一种以沟通为核心的敏捷软件开发方法，通过开发者与产品既得利益者（或其代表）之间不断的沟通，用一种双方都能理解的语言来定义和明确features。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Feature: Login</span><br><span class="line"></span><br><span class="line">  I want to login on Keepfy</span><br><span class="line"></span><br><span class="line">  Background:</span><br><span class="line">    Given I go to &apos;/login&apos;</span><br><span class="line">    And the field &apos;email&apos; is empty</span><br><span class="line">    And the field &apos;password&apos; is empty</span><br><span class="line"></span><br><span class="line">  Scenario: Error on empty fields</span><br><span class="line">    When I click on &apos;enter&apos;</span><br><span class="line">    Then field &apos;email&apos; should be with error</span><br><span class="line">    And field &apos;password&apos; should be with error</span><br><span class="line"></span><br><span class="line">  Scenario: Wrong password</span><br><span class="line">    When I type &apos;john.test@keepfy.com&apos; in &apos;email&apos;</span><br><span class="line">    And I type &apos;123456&apos; in &apos;password&apos;</span><br><span class="line">    And I click on &apos;enter&apos;</span><br><span class="line">    Then I should see &apos;E-mail or password is incorrect&apos;</span><br><span class="line"></span><br><span class="line">  Scenario: Login successfully</span><br><span class="line">    Given I have users:</span><br><span class="line">      | name           | email             | password |</span><br><span class="line">      | Vitor Batista  | vitor@keepfy.com  | abcdef   |</span><br><span class="line">    When I type &apos;vitor@keepfy.com&apos; in &apos;email&apos;</span><br><span class="line">    And I type &apos;abcdef&apos; in &apos;password&apos;</span><br><span class="line">    And I click on &apos;enter&apos;</span><br><span class="line">    Then I shouldn&apos;t see &apos;Access your account&apos;</span><br><span class="line"> to join this conversation on GitHub. Alre</span><br></pre></td></tr></table></figure></p>
<h2 id="BDD-描述"><a href="#BDD-描述" class="headerlink" title="BDD 描述"></a>BDD 描述</h2><p><img src="/2021/07/15/项目管理/BDD.png" alt="BDD"></p>
<h3 id="三个核心概念"><a href="#三个核心概念" class="headerlink" title="三个核心概念"></a>三个核心概念</h3><p>Feature、Scenario、Steps是BDD的三个核心概念，体现了BDD的三个重要价值：</p>
<ul>
<li>Living Document</li>
<li>Executable Specification by Example(SbE)</li>
<li>Automated Tests</li>
</ul>
<h4 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h4><p>Feature就像是文档一样，描述了功能特性、角色、以及 最重要的商业价值。</p>
<h4 id="Scenario"><a href="#Scenario" class="headerlink" title="Scenario"></a>Scenario</h4><p>场景就是上面提到的规范Specification。Cucumber提供了Scenario、Scenario Outline两种形式。</p>
<h4 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h4><p>Steps就是实际编码。</p>
<h2 id="敏捷中的BDD"><a href="#敏捷中的BDD" class="headerlink" title="敏捷中的BDD"></a>敏捷中的BDD</h2><h1 id="CBM方法论"><a href="#CBM方法论" class="headerlink" title="CBM方法论"></a>CBM方法论</h1><p>一种对企业进行建模和分析的技术。它是业务组件或“构建块”的逻辑表示或映射，可以在单个页面上进行描述。它可用于分析企业战略与组织能力和投资的一致性，识别冗余或重叠的业务能力，分析不同组件，确定优先级，以及映射到其他架构领域，即可帮助管理者评估整个企业的目标和战略，同时有效利用内、外部专业化的优势。。</p>
<ul>
<li>CBM 对比 TOGAF [<a href="https://dominoweb.draco.res.ibm.com/reports/rj10451.pdf" target="_blank" rel="noopener">https://dominoweb.draco.res.ibm.com/reports/rj10451.pdf</a>]<br><img src="/2021/07/15/项目管理/CBMvsTOGAF.png" alt="CBMvsTO"></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Data-Struction-Linked-List工程中应用</title>
    <url>/2021/05/24/Data-Struction-Linked-List%E5%B7%A5%E7%A8%8B%E4%B8%AD%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h1><p>简而言之，链表由node组成，每个node包含data value和next指向下一个node的指针。相比于数据，增删改时间复杂度为N（0），但查询复杂度为N（n）。为提高查询速度类似Redis中采用了Skip List。<br><img src="/2021/05/24/Data-Struction-Linked-List工程中应用/Linkedlist.png" alt="linked-list"><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Skip-List"><a href="#Skip-List" class="headerlink" title="Skip List"></a>Skip List</h2><p>在原有链表基础上，增加了维度。查询操作中，2维Skip List将next指针每次向后1位，改进为向后2位，诸如此类。<br><img src="/2021/05/24/Data-Struction-Linked-List工程中应用/SkipList.png" alt="linked-list"></p>
<p>可参考<br><a href="https://www.jianshu.com/p/fd4a4248cf2d" target="_blank" rel="noopener">https://www.jianshu.com/p/fd4a4248cf2d</a><br><a href="https://www.jianshu.com/p/a85e392118a9" target="_blank" rel="noopener">https://www.jianshu.com/p/a85e392118a9</a><br><a href="https://www.cnblogs.com/learnhow/p/6749648.html" target="_blank" rel="noopener">https://www.cnblogs.com/learnhow/p/6749648.html</a></p>
<h2 id="leetcode-LRU缓存算法"><a href="#leetcode-LRU缓存算法" class="headerlink" title="leetcode-LRU缓存算法"></a>leetcode-LRU缓存算法</h2><p><a href="https://www.jianshu.com/p/b1ab4a170c3c" target="_blank" rel="noopener">https://www.jianshu.com/p/b1ab4a170c3c</a></p>
]]></content>
  </entry>
  <entry>
    <title>Wireshark使用建议</title>
    <url>/2021/03/15/Wireshark%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<p>基于平时学习，总结几点wireshark使用建议。</p>
<h1 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h1><p>安装好Wireshark之后，启动Wireshark并在界面想抓的链路，例如本机开启wifi后在<code>控制面板\所有控制面板项\网络连接</code>中可查看开启热点网络。选择抓取网络：<br><img src="/2021/03/15/Wireshark使用建议/首页.png" alt="选取网络"></p>
<h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><p>双击开始抓包后，可在笔记本或终端操作，此时wireshark便抓取了整个链路数据，例如：<br><img src="/2021/03/15/Wireshark使用建议/抓包.png" alt="一条完整链路"><br>显示的是访问http明文网站所产生的完整的链路数据。头三个包是TCP三次握手，接着是一个HTTP包，即为访问网页所产生的HTTP数据。</p>
<p>Wireshark基本操作网上比比皆是，以下列举几个讲解较全的：</p>
<ul>
<li>[1] <a href="https://zhuanlan.zhihu.com/p/31512066" target="_blank" rel="noopener">操作建议</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Wireshark代码解析</title>
    <url>/2020/06/09/Wireshark%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>wireshark官网获取源代码解读。</p>
<h1 id="二、Wireshark功能模块"><a href="#二、Wireshark功能模块" class="headerlink" title="二、Wireshark功能模块"></a>二、Wireshark功能模块</h1><p>下图给出了wireshark功能模块：<br><img src="/2020/06/09/Wireshark代码解析/wireshark_func.jpg" alt="wireshark_func"></p>
<ul>
<li><p>GTK1/2<br>处理用户的输入输出显示，源码在gtk目录.</p>
</li>
<li><p>Core<br>核心模块，通过函数调用将其他模块连接在一起，源码在根目录</p>
</li>
<li><p>Epan<br>wireshark Packetage Analyzing，包分析引擎，源码在epan目录</p>
</li>
</ul>
<ul>
<li>Protocol-Tree：保存数据包的协议信息，wireshark的协议结构采用树形结构，解析协议报文时只需要从根节点通过函数句柄依次调用各层解析函数即可。</li>
<li>Dissectors：在epan/dissector目录下，各种协议解码器，支持700+种协议解析，对于每种协议，解码器都能识别出协议字段（field），并显示出字段值（field value）由于网络协议种类很多，为了使协议和协议间层次关系明显，对数据流里的各个层次的协议能够逐层处理，wireshark系统采用了协议树的方式。</li>
<li>Plugins：一些协议解码器以插件形式实现，源码在plugins目录</li>
<li>Display-Filters：显示过滤引擎，源码在epan/dfilter目录</li>
</ul>
<ul>
<li><p>Capture<br>捕包引擎，利用libpcap/WinPcap从底层抓取网络数据包，libpcap/WinPcap提供了通用的抓包接口，能从不同类型的网络接口(包括以太网，令牌环网，ATM网等)获取数据包。</p>
</li>
<li><p>Wiretap<br>从文件中读取数据包，支持多种文件格式，源码在wiretap目录<br><img src="/2020/06/09/Wireshark代码解析/wiretap.gif" alt="wiretap"></p>
</li>
<li>Win-/libpcap<br>Wireshark抓包时依赖的库文件，抓包时依赖的库文件</li>
</ul>
<h1 id="三、wireshark流程分析"><a href="#三、wireshark流程分析" class="headerlink" title="三、wireshark流程分析"></a>三、wireshark流程分析</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>入口代码应该是在gtk\main.c下</p>
<ul>
<li>create_main_window</li>
<li>gtk_main</li>
</ul>
<p>Wireshark的初始化包括一些全局变量的初始化、协议分析引擎的初始化和Gtk相关初始化，显示Ethereal主窗口，等待用户进一步操作。重点就是Epan模块的初始化。</p>
<ul>
<li>Epan初始化：</li>
<li>tvbuff初始化：全局变量tvbuff_mem_chunk指向用memchunk分配的固定大小的空闲内存块，每个内存块是tvbuff_t结构，从空闲内存块中取出后，用来保存原始数据包。</li>
<li>协议初始化：</li>
<li>全局变量：<ul>
<li>proto_names</li>
<li>proto_short_names</li>
<li>proto_filter_names<br>以上三个全局变量主要用来判断新注册的协议名是否重复，如果重复，给出提示信息，在协议解析过程中并没有使用。</li>
</ul>
</li>
</ul>
<h3 id="协议注册："><a href="#协议注册：" class="headerlink" title="协议注册："></a>协议注册：</h3><p>注册协议：将三个参数分别注册给proto_names、proto_short_names、proto_filter_names三个全局变量中，<br>注册字段,需要在wireshark协议树显示的报文内容字段。<br>协议解析表<br>Handoff注册<br>将协议与父协议节点关联起来<br>Packet（包）初始化<br>全局变量：<br>frame_handle：协议解析从frame开始，层层解析，直到所有的协议都解析完为止。frame_handle保存了frame协议的handle。在dissect_packet函数相关代码。<br>data_handle：有的协议无法从frame开始，那么就从data开始。原理同frame。<br>读配置文件preference<br>读capture filter和display filter文件，分别保存在全局变量capture_filter和display_filter中。<br>读disabled protocols文件，保存全局变量global_disabled_protos和disabled_protos中<br>初始化全局变量cfile<br>Cfile是个重要的变量，数据类型为capture file，它保存了数据包的所有信息，<br>取得命令行启动时，参数列表，并进行相应的处理<br>处理流程<br>Wireshark初始化完成以后进入实际处理阶段，主程序创建抓包进程，捕包进程和主程序是通过PIPE进行传递数据的，主程序把抓取的数据写入临时文件，通过函数add_packet_to_packet_list将数据包加入包列表。处理时，主程序从列表中选取一个数据包，提取该数据包中的数据填写在数据结构中，最后调用协议解析函数epan_dissect_run进行处理，从epan_dissect_run开始，是实际的协议解析过程，</p>
<h2 id="下面以HTTP协议报文为例，流程如下："><a href="#下面以HTTP协议报文为例，流程如下：" class="headerlink" title="下面以HTTP协议报文为例，流程如下："></a>下面以HTTP协议报文为例，流程如下：</h2><h3 id="解析frame层"><a href="#解析frame层" class="headerlink" title="解析frame层"></a>解析frame层</h3><p>调用函数dissect_frame对frame层进行解析，并在协议树上填充相应字段信息。函数最后会判断是否有上层协议封装，如果有则调用函数dissector_try_port在协议树上查找对应的解析函数，这里函数dissector_try_port根据pinfo-&gt;fd-&gt;lnk_t查找对应的上层协议处理函数，pinfo-&gt;fd-&gt;lnk_t值为1，上层封装协议为以太网协议，全局结构体指针变量dissector_handle当前的协议解析引擎句柄置为dissect_eth_maybefcs，至此，frame层解析结束。</p>
<h3 id="解析以太网层"><a href="#解析以太网层" class="headerlink" title="解析以太网层"></a>解析以太网层</h3><p>函数call_dissector_work根据dissector_handle调用frame上层协议解析函数dissect_eth_maybefcs对以太网层进行解析，并在协议树上填充相应字段，包括目的MAC地址和以太网上层协议类型等信息。函数最后会判断是否有上层协议封装，如果有则调用函数dissector_try_port在协议树上查找对应的解析函数，这里函数dissector_try_port根据etype查找对应的上层协议处理函数，以太网字段etype为0800的报文是ip报文，上层封装协议为IP协议，全局结构体指针变量dissector_handle当前的协议解析引擎句柄置为dissect_ip，至此，以太网层解析结束。</p>
<h3 id="解析IP层"><a href="#解析IP层" class="headerlink" title="解析IP层"></a>解析IP层</h3><p>函数call_dissector_work根据dissector_handle调用以太网上层协议解析函数dissect_ip对以太网层进行解析，并在协议树上填充相应字段，包括版本号，源地址，目的地址等信息。函数最后会判断是否有上层协议封装，如果有则调用函数dissector_try_port在协议树上查找对应的解析函数，这里函数dissector_try_port根据nxt (nxt = iph-&gt;ip_p)查找对应的上层协议处理函数，以太网字段nxt为06的报文是TCP报文，上层封装协议为TCP协议，全局结构体指针变量dissector_handle当前的协议解析引擎句柄置为dissect_tcp，至此，IP层解析结束。</p>
<h3 id="解析TCP层"><a href="#解析TCP层" class="headerlink" title="解析TCP层"></a>解析TCP层</h3><p>函数call_dissector_work根据dissector_handle调用以太网上层协议解析函数dissect_tcp对TCP层进行解析，包括对TCP头的解析和选项字段的解析，并在协议树上填充相应字段，包括源端口，目的端口，标志位等信息。函数最后会判断是否有上层协议封装，如果有则调用函数dissector_try_port在协议树上查找对应的解析函数，这里函数dissector_try_port根据port查找对应的上层协议处理函数，将源端口和目的端口分别赋值给low_port和high_port，根据low_port和high_port分别匹配上层协议解析函数，port为80的报文是HTTP报文，上层封装协议为HTTP协议，全局结构体指针变量dissector_handle当前的协议解析引擎句柄置为dissect_http，至此，TCP层解析结束。</p>
<h3 id="解析HTTP层"><a href="#解析HTTP层" class="headerlink" title="解析HTTP层"></a>解析HTTP层</h3><p>至此wireshark进入应用层协议检测阶段，wireshark解析dissect_http函数中注册的字段，并提取相应的字段值添加到协议树中，应用层的具体解析流程将在下面介绍。HTTP协议具体函数调用过程参见：</p>
<h1 id="四、重要的数据结构"><a href="#四、重要的数据结构" class="headerlink" title="四、重要的数据结构"></a>四、重要的数据结构</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">epan_dissect_t</span> &#123;</span></span><br><span class="line"><span class="keyword">tvbuff_t</span> *tvb;<span class="comment">//用来保存原始数据包</span></span><br><span class="line">proto_tree *tree;<span class="comment">//协议树结构</span></span><br><span class="line">packet_info pi;<span class="comment">// 包括各种关于数据包和协议显示的相关信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Each proto_tree, proto_item is one of these. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">proto_node</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">proto_node</span> *<span class="title">first_child</span>;</span><span class="comment">//协议树节点的第一个子节点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">proto_node</span> *<span class="title">last_child</span>;</span> <span class="comment">//协议树节点的最后一个子节点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">proto_node</span> *<span class="title">next</span>;</span> <span class="comment">//协议树节点的下一个节点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">proto_node</span> *<span class="title">parent</span>;</span><span class="comment">//父节点指针</span></span><br><span class="line">field_info *finfo;<span class="comment">//保存当前协议要显示的地段</span></span><br><span class="line"><span class="keyword">tree_data_t</span> *tree_data;<span class="comment">//协议树信息</span></span><br><span class="line">&#125; proto_node;</span><br><span class="line"></span><br><span class="line">packet_info</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">packet_info</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *current_proto; <span class="comment">//当前正在解析的协议名称</span></span><br><span class="line">column_info *cinfo; <span class="comment">//wireshark显示的信息</span></span><br><span class="line">frame_data *fd;<span class="comment">//现在分析的原始数据指针</span></span><br><span class="line"><span class="keyword">union</span> wtap_pseudo_header *pseudo_header;<span class="comment">//frame类型信息</span></span><br><span class="line">GSList *data_src; <span class="comment">/*frame层信息 */</span></span><br><span class="line">address dl_src; <span class="comment">/* 源MAC */</span></span><br><span class="line">address dl_dst; <span class="comment">/*目的MAC */</span></span><br><span class="line">address net_src; <span class="comment">/* 源IP */</span></span><br><span class="line">address net_dst; <span class="comment">/*目的IP */</span></span><br><span class="line">address src; <span class="comment">/*源IP */</span></span><br><span class="line">address dst; <span class="comment">/*目的IP */</span></span><br><span class="line">guint32 ethertype; <span class="comment">/*以太网类型字段*/</span></span><br><span class="line">guint32 ipproto; <span class="comment">/* IP协议类型*/</span></span><br><span class="line">guint32 ipxptype; <span class="comment">/* IPX 包类型 */</span></span><br><span class="line">guint32 mpls_label; <span class="comment">/* MPLS包标签*/</span></span><br><span class="line">circuit_type ctype;</span><br><span class="line">guint32 circuit_id; <span class="comment">/*环路ID */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *noreassembly_reason; <span class="comment">/* 重组失败原因*/</span></span><br><span class="line">gboolean fragmented; <span class="comment">/*为真表示未分片*/</span></span><br><span class="line">gboolean in_error_pkt; <span class="comment">/*错误包标志*/</span></span><br><span class="line">port_type ptype; <span class="comment">/*端口类型 */</span></span><br><span class="line">guint32 srcport; <span class="comment">/*源端口*/</span></span><br><span class="line">guint32 destport; <span class="comment">/*目的端口*/</span></span><br><span class="line">guint32 match_port; <span class="comment">/*进行解析函数匹配时的匹配端口*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *match_string; <span class="comment">/*调用子解析引擎时匹配的协议字段指针*/</span></span><br><span class="line">guint16 can_desegment; <span class="comment">/* 能否分段标志*/</span></span><br><span class="line">guint16 saved_can_desegment;</span><br><span class="line"><span class="keyword">int</span> desegment_offset; <span class="comment">/*分段大小*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DESEGMENT_ONE_MORE_SEGMENT 0x0fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DESEGMENT_UNTIL_FIN 0x0ffffffe</span></span><br><span class="line">guint32 desegment_len;</span><br><span class="line">guint16 want_pdu_tracking;</span><br><span class="line">guint32 bytes_until_next_pdu;</span><br><span class="line"><span class="keyword">int</span> iplen; <span class="comment">/*IP包总长*/</span></span><br><span class="line"><span class="keyword">int</span> iphdrlen; <span class="comment">/*IP头长度*/</span></span><br><span class="line"><span class="keyword">int</span> p2p_dir;</span><br><span class="line">guint16 oxid; <span class="comment">/* next 2 fields reqd to identify fibre */</span></span><br><span class="line">guint16 rxid; <span class="comment">/* channel conversations */</span></span><br><span class="line">guint8 r_ctl; <span class="comment">/* R_CTL field in Fibre Channel Protocol */</span></span><br><span class="line">guint8 sof_eof;</span><br><span class="line">guint16 src_idx; <span class="comment">/* Source port index (Cisco MDS-specific) */</span></span><br><span class="line">guint16 dst_idx; <span class="comment">/* Dest port index (Cisco MDS-specific) */</span></span><br><span class="line">guint16 vsan; <span class="comment">/* Fibre channel/Cisco MDS-specific */</span></span><br><span class="line"><span class="comment">/* Extra data for DCERPC handling and tracking of context ids */</span></span><br><span class="line">guint16 dcectxid; <span class="comment">/* Context ID (DCERPC-specific) */</span></span><br><span class="line"><span class="keyword">int</span> dcetransporttype;</span><br><span class="line">guint16 dcetransportsalt; <span class="comment">/* fid: if transporttype==DCE_CN_TRANSPORT_SMBPIPE */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECRYPT_GSSAPI_NORMAL 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECRYPT_GSSAPI_DCE 2</span></span><br><span class="line">guint16 decrypt_gssapi_tvb;</span><br><span class="line"><span class="keyword">tvbuff_t</span> *gssapi_wrap_tvb;</span><br><span class="line"><span class="keyword">tvbuff_t</span> *gssapi_encrypted_tvb;</span><br><span class="line"><span class="keyword">tvbuff_t</span> *gssapi_decrypted_tvb;</span><br><span class="line">gboolean gssapi_data_encrypted;</span><br><span class="line">guint32 ppid; <span class="comment">/* SCTP PPI of current DATA chunk */</span></span><br><span class="line">guint32 ppids[MAX_NUMBER_OF_PPIDS]; <span class="comment">/* The first NUMBER_OF_PPIDS PPIDS which are present * in the SCTP packet*/</span></span><br><span class="line"><span class="keyword">void</span> *private_data; <span class="comment">/* pointer to data passed from one dissector to another */</span></span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> Use emem_strbuf_t instead */</span></span><br><span class="line">GString *layer_names; <span class="comment">/* layers of each protocol */</span></span><br><span class="line">guint16 link_number;</span><br><span class="line">guint8 annex_a_used;</span><br><span class="line">guint16 profinet_type; <span class="comment">/* the type of PROFINET packet (0: not a PROFINET packet) */</span></span><br><span class="line"><span class="keyword">void</span> *profinet_conv; <span class="comment">/* the PROFINET conversation data (NULL: not a PROFINET packet) */</span></span><br><span class="line"><span class="keyword">void</span> *usb_conv_info;</span><br><span class="line"><span class="keyword">void</span> *tcp_tree; <span class="comment">/* proto_tree for the tcp layer */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *dcerpc_procedure_name; <span class="comment">/* Used by PIDL to store the name of the current dcerpc procedure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">sccp_msg_info_t</span>* <span class="title">sccp_info</span>;</span></span><br><span class="line">guint16 clnp_srcref; <span class="comment">/* clnp/cotp source reference (can't use srcport, this would confuse tpkt) */</span></span><br><span class="line">guint16 clnp_dstref; <span class="comment">/* clnp/cotp destination reference (can't use dstport, this would confuse tpkt) */</span></span><br><span class="line">guint16 zbee_cluster_id; <span class="comment">/* ZigBee cluster ID, an application-specific message identifier that</span></span><br><span class="line"><span class="comment">* happens to be included in the transport (APS) layer header.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">guint8 zbee_stack_vers; <span class="keyword">int</span> link_dir; <span class="comment">/* 3GPP messages are sometime different UP link(UL) or Downlink(DL)*/</span></span><br><span class="line">&#125; packet_info;</span><br></pre></td></tr></table></figure>
<h1 id="五、重要函数理解"><a href="#五、重要函数理解" class="headerlink" title="五、重要函数理解"></a>五、重要函数理解</h1><p>1、<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```c</span><br><span class="line">static void</span><br><span class="line">dissect_foo(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)</span><br><span class="line">&#123;</span><br><span class="line">col_set_str(pinfo-&gt;cinfo, COL_PROTOCOL, &quot;FOO&quot;);</span><br><span class="line">/* Clear out stuff in the info column */</span><br><span class="line">col_clear(pinfo-&gt;cinfo,COL_INFO);</span><br><span class="line">if (tree) &#123; /* we are being asked for details */</span><br><span class="line">proto_item *ti = NULL;</span><br><span class="line">ti = proto_tree_add_item(tree, proto_foo, tvb, 0, -1, FALSE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们要做的是在分解过程中增加一个子树。此子树将包含此协议的所有细节，因此在不需要时不会使显示混乱。<br>我们还标记了该协议所使用的数据区域。在我们的例子中，它是传递给我们的全部内容，因为我们假设这个协议没有封装另一个协议。因此，我们使用proto_tree_add_item()添加新的树节点，将其添加到传入的树中，用协议对其进行标签，使用tvb缓冲区中传入的数据，并从0到结束(-1)使用该数据。我们先忽略错误。</p>
<p>2、<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3、```header_field_info</span><br></pre></td></tr></table></figure></p>
<p>对协议中的每个域都会注册一个header_field_info对象，它描述了此协议域的显示名称，filer中的使用的名称，数据类型以及显示格式等等。 </p>
<h1 id="六、代码结构"><a href="#六、代码结构" class="headerlink" title="六、代码结构"></a>六、代码结构</h1><p>TAP的理解<br>TSHARK_TAP_SRC<br>踪迹分析程序</p>
]]></content>
  </entry>
  <entry>
    <title>物联网协议</title>
    <url>/2020/06/09/%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="CoAP协议"><a href="#CoAP协议" class="headerlink" title="CoAP协议"></a>CoAP协议</h1><p>受限应用协议(CoAP)是一种专门针对受限设备的Internet应用协议，定义在RFC 7252中。它使那些被称为“节点”的受限设备能够使用类似的协议与更广泛的Internet通信。</p>
<h2 id="协议识别规则"><a href="#协议识别规则" class="headerlink" title="协议识别规则"></a>协议识别规则</h2><p>CoAP是一个完整的二进制应用层协议，默认运行在UDP上，端口为5683和5684。<br>CoAP数据包格式<br>如果省略令牌、选项和有效负载，最小的CoAP消息长度为4字节。CoAP使用简单的二进制基本头格式，利用了两种消息类型:请求和响应。基本标头后面可以跟着优化的类型-长度-值格式的选项。CoAP默认绑定到UDP，也可以绑定到DTLS，提供了高水平的通信安全性。</p>
<h2 id="CoAP首部"><a href="#CoAP首部" class="headerlink" title="CoAP首部"></a>CoAP首部</h2><p><img src="/2020/06/09/物联网协议/coap_header.png" alt="coap_header"><br>•    【Ver】版本编号。<br>•    【T】报文类型，CoAP协议定了4种不同形式的报文，CON报文，NON报文，ACK报文和RST报文。<br>•    【TKL】CoAP标识符长度。CoAP协议中具有两种功能相似的标识符，一种为Message ID(报文编号)，一种为Token(标识符)。其中每个报文均包含消息编号，但是标识符对于报文来说是非必须的。<br>•    【Code】功能码/响应码。Code在CoAP请求报文和响应报文中具有不同的表现形式，Code占一个字节，它被分成了两部分，前3位一部分，后5位一部分，为了方便描述它被写成了c.dd结构。其中0.XX表示CoAP请求的某种方法，而2.XX、4.XX或5.XX则表示CoAP响应的某种具体表现。<br>•    【Message ID】报文编号。<br>•    【Token】标识符具体内容，通过TKL指定Token长度。<br>•    【Option】报文选项，通过报文选项可设定CoAP主机，CoAP URI，CoAP请求参数和负载媒体类型等等。<br>•    【1111 1111B】CoAP报文和具体负载之间的分隔符。<br>Code请求方法<br>•    GET：获取资源<br>•    POST：创建资源<br>•    PUT：更新资源<br>•    DELETE：删除资源</p>
<h1 id="MQTT协议"><a href="#MQTT协议" class="headerlink" title="MQTT协议"></a>MQTT协议</h1><p>协议就是通信双方的一个约定。在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、 可变头（Variable header）、 消息体（payload）三部分构成。</p>
<h2 id="协议识别规则-1"><a href="#协议识别规则-1" class="headerlink" title="协议识别规则"></a>协议识别规则</h2><p>端口1883，ssl-mqtt默认端口为8883。</p>
<h2 id="MQTT-数据包结构"><a href="#MQTT-数据包结构" class="headerlink" title="MQTT 数据包结构"></a>MQTT 数据包结构</h2><p>•    固定头（Fixed header），存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识<br>•    可变头（Variable header），存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容<br>•    消息体（Payload），存在于部分MQTT数据包中，表示客户端收到的具体内容</p>
<h3 id="1-MQTT固定头"><a href="#1-MQTT固定头" class="headerlink" title="1 MQTT固定头"></a>1 MQTT固定头</h3><p>固定头存在于所有MQTT数据包中，其结构如下：<br><img src="/2020/06/09/物联网协议/mqtt_header.png" alt="mqtt_header"></p>
<h4 id="1-1-MQTT数据包类型"><a href="#1-1-MQTT数据包类型" class="headerlink" title="1.1 MQTT数据包类型"></a>1.1 MQTT数据包类型</h4><p>相于一个4位的无符号值，类型如下：<br><img src="/2020/06/09/物联网协议/mqtt_stru.png" alt="mqtt_structure"></p>
<h4 id="1-2-标识位"><a href="#1-2-标识位" class="headerlink" title="1.2 标识位"></a>1.2 标识位</h4><p>固定报头第1个字节的剩余的4位 [3-0]包含每个MQTT控制报文类型特定的标志。</p>
<h4 id="1-3-剩余长度（Remaining-Length）"><a href="#1-3-剩余长度（Remaining-Length）" class="headerlink" title="1.3 剩余长度（Remaining Length）"></a>1.3 剩余长度（Remaining Length）</h4><p>位置：从第2个字节开始。<br>剩余长度（Remaining Length）表示当前报文剩余部分的字节数，包括可变报头和负载的数据。剩余长度不包括用于编码剩余长度字段本身的字节数。</p>
<h3 id="2-MQTT可变头"><a href="#2-MQTT可变头" class="headerlink" title="2 MQTT可变头"></a>2 MQTT可变头</h3><p>MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是做为包的标识：<br><img src="/2020/06/09/物联网协议/mqtt_header_changable.png" alt="mqtt_header2"><br>很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK</p>
<h3 id="3-有效载荷-Payload"><a href="#3-有效载荷-Payload" class="headerlink" title="3 有效载荷 Payload"></a>3 有效载荷 Payload</h3><p>有效载荷Payload位MQTT数据包的第三部分，CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息<br>有消息体：<br>•    CONNECT，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码。<br>•    SUBSCRIBE，消息体内容是一系列的要订阅的主题以及QoS。<br>•    SUBACK，消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复。<br>•    UNSUBSCRIBE，消息体内容是要订阅的主题。</p>
<h3 id="4-消息体长度-Msg-Len"><a href="#4-消息体长度-Msg-Len" class="headerlink" title="4 消息体长度 Msg_Len"></a>4 消息体长度 Msg_Len</h3><p>首先需要了解varints。Varint是一种使用一个或多个字节序列化整数的方法。较小的数字占用较少的字节数。</p>
<p>除了最后一个字节外，varint中的每个字节都设置了最高有效位（msb）–这表明还会有其他字节。每个字节的低7位用于以7位为一组存储数字的二进制补码表示，最低有效组在前。</p>
<p>因此，例如，这里是数字1 –它是一个字节，因此未设置msb：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000 0001</span><br></pre></td></tr></table></figure></p>
<p>这是300 –这有点复杂：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1010 1100 0000 0010</span><br></pre></td></tr></table></figure></p>
<p>您如何确定这是300？首先，从每个字节中删除msb，因为这是在告诉我们是否已到达数字的末尾（如您所见，它在第一个字节中设置，因为varint中有多个字节） ：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1010 1100 0000 0010   </span><br><span class="line">→ 010 1100 000 0010</span><br></pre></td></tr></table></figure></p>
<p>反转两组7位，因为您记得，varint存储数字时最低有效组在前。然后，将它们连接起来以获得最终值：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000 0010 010 1100   </span><br><span class="line">→ 000 0010 ++ 010 1100    </span><br><span class="line">→ 100101100</span><br><span class="line">→ 256 + 32 + 8 + 4 = 300</span><br></pre></td></tr></table></figure></p>
<p>讯息结构<br>如您所知，协议缓冲区消息是一系列键值对。消息的二进制版本仅使用字段的编号作为关键字-每个字段的名称和声明的类型只能在解码端通过引用消息类型的定义（即.proto文件）来确定。</p>
<p>对消息进行编码后，键和值将串联成一个字节流。解码消息时，解析器需要能够跳过无法识别的字段。这样，可以将新字段添加到消息中，而不会破坏不知道它们的旧程序。为此，有线格式消息中每对的“键”实际上是两个值– .proto文件中的字段编号，加上提供的信息恰好足以找到以下值的长度的有线类型。在大多数语言实现中，此键称为标签。</p>
<p>流式消息中的每个键都是具有值的varint- (field_number &lt;&lt; 3) | wire_type换句话说，数字的最后三位用于存储导线类型。</p>
<p>现在，让我们再来看一个简单的例子。您现在知道流中的第一个数字始终是varint键，这里是08，或者（删除msb）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000 1000</span><br></pre></td></tr></table></figure></p>
<p>使用最后三位获得类型（0），然后右移三位以获得字段编号（1）。因此，您现在知道字段号为1，并且以下值为varint。使用上一节中的varint解码知识，您可以看到接下来的两个字节存储值150。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">96 01 = 1001 0110 0000 0001      </span><br><span class="line">       → 000 0001 ++ 001 0110 （删除msb并反转7 位组）        </span><br><span class="line">       → 10010110 </span><br><span class="line">       → 128 + 16 + 4 + 2 = 150</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/06/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><h2 id="一-操作系统引论"><a href="#一-操作系统引论" class="headerlink" title="一.操作系统引论"></a>一.操作系统引论</h2><h3 id="1-操作系统的目标和功能"><a href="#1-操作系统的目标和功能" class="headerlink" title="1.操作系统的目标和功能"></a>1.操作系统的目标和功能</h3><ul>
<li>目标<ul>
<li>方便性</li>
<li>有效性<ul>
<li>提高系统资源利用率</li>
<li>提高系统吞吐量</li>
</ul>
</li>
<li>可扩充性</li>
<li>开放性</li>
</ul>
</li>
<li>作用<ul>
<li>OS作为用户与计算机硬件系统之间的接口<ul>
<li>命令方式</li>
<li>系统调用方式</li>
<li>图标–窗口方式</li>
</ul>
</li>
<li>OS实现了对计算机资源的抽象<h3 id="2-操作系统的发展过程"><a href="#2-操作系统的发展过程" class="headerlink" title="2.操作系统的发展过程"></a>2.操作系统的发展过程</h3></li>
</ul>
</li>
<li><p>未配置操作系统的计算机系统</p>
<ul>
<li><p>人工操作方式</p>
<ul>
<li><blockquote>
<p>用户独占全机 CPU等待人工操作 严重降低了计算机资源的利用率</p>
</blockquote>
</li>
</ul>
</li>
<li><p>脱机输入/输出(Off–Line I/O)方式</p>
<ul>
<li><blockquote>
<p>减少了CPU的空闲时间 提高了I/O速度 效率仍然不理想</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>单道批处理系统</p>
</li>
<li>多道批处理系统</li>
<li><blockquote>
<p>1.资源利用率高</p>
</blockquote>
</li>
<li><blockquote>
<p>2.系统吞吐量大</p>
</blockquote>
</li>
<li><blockquote>
<p>3.平均周转时间长</p>
</blockquote>
</li>
<li><blockquote>
<p>4.无交互能力</p>
</blockquote>
<ul>
<li>(宏观并行，微观串行)</li>
</ul>
</li>
<li>分时系统</li>
<li><blockquote>
<p>特征:</p>
</blockquote>
</li>
<li><blockquote>
<p>1.多路性</p>
</blockquote>
</li>
<li><blockquote>
<p>2.独立性</p>
</blockquote>
</li>
<li><blockquote>
<p>3.及时性</p>
</blockquote>
</li>
<li><blockquote>
<p>4.交互性</p>
</blockquote>
</li>
<li><p>实时系统</p>
</li>
<li>集群系统–超算~云计算</li>
<li>微机操作系统的发展<h3 id="3-操作系统的基本特征"><a href="#3-操作系统的基本特征" class="headerlink" title="3.操作系统的基本特征"></a>3.操作系统的基本特征</h3></li>
<li><p>1.并发concurrence</p>
<ul>
<li><p>区别并行和并发</p>
<ul>
<li><blockquote>
<p>并行性是指两个或多个事件在同一时刻发生→宏观并行，微观并行</p>
</blockquote>
</li>
<li><blockquote>
<p>并发性是指两个或多个事件在同一时间间隔内发生→宏观并行，微观串行</p>
</blockquote>
<ul>
<li>并发是进程宏观一起运行，微观上交替运行，而并行是指同时运行</li>
</ul>
</li>
</ul>
</li>
<li>引入进程<ul>
<li><blockquote>
<p>进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令，数据和堆栈等组成的，是一个能独立运行的活动实体</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2.共享sharing</p>
<ul>
<li>1.互斥共享方式</li>
<li>2.同时访问方式</li>
<li>并发和共享是多用户(多任务)OS的两个最基本的特征。它们又是互为存在的条件</li>
</ul>
</li>
<li>3.虚拟virtual<ul>
<li>时分复用技术</li>
<li>空分复用技术</li>
</ul>
</li>
<li>4.异步asynchronism<h3 id="4-操作系统的主要功能"><a href="#4-操作系统的主要功能" class="headerlink" title="4.操作系统的主要功能"></a>4.操作系统的主要功能</h3></li>
<li>1.处理机管理功能<ul>
<li>进程控制</li>
<li>进程同步<ul>
<li>进程互斥方式</li>
<li>进程同步方式(协同)</li>
</ul>
</li>
<li>进程通信</li>
<li>调度<ul>
<li>作业调度</li>
<li>进程调度</li>
</ul>
</li>
</ul>
</li>
<li>2.存储器管理功能<ul>
<li>内存分配<ul>
<li>静态分配</li>
<li>动态分配</li>
</ul>
</li>
<li>内存保护</li>
<li>地址映射</li>
<li>内存扩充</li>
</ul>
</li>
<li>3.设备管理功能<ul>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备处理<ul>
<li>设备处理程序又称设备驱动程序</li>
</ul>
</li>
</ul>
</li>
<li>4.文件管理功能<ul>
<li>文件存储空间的管理</li>
<li>目录管理</li>
<li>文件的读写管理和保护</li>
</ul>
</li>
<li>5.操作系统与用户之间的接口<ul>
<li>用户接口</li>
<li>程序接口</li>
</ul>
</li>
<li>6.现代操作系统的新功能<ul>
<li>系统安全</li>
<li>网络的功能和服务</li>
<li>支持多媒体<h3 id="5-OS结构设计"><a href="#5-OS结构设计" class="headerlink" title="5.OS结构设计"></a>5.OS结构设计</h3></li>
</ul>
</li>
<li>传统操作系统结构<ul>
<li>无结构操作系统</li>
<li>模块化OS</li>
<li>分层式结构OS</li>
</ul>
</li>
<li>微内核os结构<ul>
<li>客户/服务器模式</li>
<li>面对对象的程序设计<h2 id="第二章进程的描述与控制"><a href="#第二章进程的描述与控制" class="headerlink" title="第二章进程的描述与控制"></a>第二章进程的描述与控制</h2><h3 id="前驱图和程序执行"><a href="#前驱图和程序执行" class="headerlink" title="前驱图和程序执行"></a>前驱图和程序执行</h3><h3 id="程序并发执行"><a href="#程序并发执行" class="headerlink" title="程序并发执行"></a>程序并发执行</h3></li>
</ul>
</li>
<li>程序的并发执行</li>
<li>程序并发执行时的特征<ul>
<li>间断性</li>
<li>失去封闭性</li>
<li>不可再现性<h3 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h3></li>
</ul>
</li>
<li>进程的定义<ul>
<li>进程是程序的一次执行</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li>
<li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>
</ul>
</li>
<li>进程的组成<ul>
<li>PCB（进程存在的唯一标识）<ul>
<li>进程描述信息</li>
<li>进程控制和管理信息</li>
<li>资源分配清单</li>
<li>处理机相关信息</li>
</ul>
</li>
<li>程序段<ul>
<li>程序的代码（指令序列）</li>
</ul>
</li>
<li>数据段<ul>
<li>运行过程中产生的各种数据</li>
</ul>
</li>
</ul>
</li>
<li>进程的特征<ul>
<li>动态性（进程的<strong>最基本特性</strong>）</li>
<li>并发性</li>
<li>独立性（进程是能够独立运行、独立获取资源、独立接受调度的基本单位）</li>
<li>异步性</li>
<li>结构性</li>
</ul>
</li>
<li>从操作系统角度分类<ul>
<li>系统进程</li>
<li>用户进程</li>
</ul>
</li>
<li>进程和程序的区别<ul>
<li>进程是动态概念，而程序则是静态概念</li>
<li>程序是指令的有序集合，永远存在；进程强调是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；</li>
<li>进程具有并发性，而程序没有</li>
<li>进程可创建其他进程，而程序并不能形成新的程序</li>
<li>进程是竞争计算机资源的基本单位，程序不是</li>
</ul>
</li>
<li>进程和程序的联系<ul>
<li>进程是程序在数据集上的一次执行</li>
<li>程序是构成进程的组成部分，一个程序可对应多个进程，一个进程可包括多个程序</li>
<li>进程的运行目标是执行所对应的程序</li>
<li>从静态看，进程由程序、数据和进程控制块（PCB）组成</li>
</ul>
</li>
<li><p>进程的基本状态及转换</p>
<ul>
<li><p>进程的三种基本状态<strong>【重点】</strong></p>
<ul>
<li><p>运行状态（Running）CPU<figure class="highlight plain"><figcaption><span>其他所需资源```√```</span></figcaption><table><tr><td class="code"><pre><span class="line">* 就绪状态（Ready）CPU```×``` 其他所需资源```√</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>阻塞状态（Waiting/Blocked，又称等待态）CPU<code>×</code> 其他所需资源<code>×</code></p>
</li>
</ul>
</li>
<li>三种基本状态的转换<strong>【重点】</strong><ul>
<li>就绪态-》运行态（进程被调度）</li>
<li>运行态-》就绪态（时间片到，或CPU被其他高优先级进程抢占）</li>
<li>运行态-》阻塞态（等待资源系统分配，或等待某事件发生<em>主动行为</em>）</li>
<li>阻塞态-》就绪态（资源分配到位，等待的事件发生<em>被动行为</em>）</li>
</ul>
</li>
<li>创建状态和终止状态<ul>
<li>五状态进程模型<ul>
<li>创建态-就绪态-运行态-阻塞态-终止态</li>
</ul>
</li>
</ul>
</li>
<li>注意<ul>
<li>阻塞态-&gt;运行态和就绪态-&gt;阻塞态这二种状态转换不可能发生</li>
<li>进程PCB中，会有一个变量statue来标识进程的当前状态</li>
</ul>
</li>
</ul>
</li>
<li>挂起操作和进程状态的转换<ul>
<li>挂起和阻塞的区别</li>
<li>挂起操作的目的<ul>
<li>终端用户的需要: 修改、检查进程</li>
<li>父进程的需要：修改、协调子进程</li>
<li>对换的需要：缓和内存</li>
<li>负荷调节的需要：保证实时任务的执行</li>
</ul>
</li>
<li>关键图</li>
</ul>
</li>
<li>进程管理中的数据结构<ul>
<li>进程控制块PCB的作用<ul>
<li>作为独立运行基本单位的标志</li>
<li>能实现间断性运行方式</li>
<li>提供进程管理所需要的信息</li>
<li>提供进程调度所需要的信息</li>
<li>实现与其他进程的同步与通信</li>
</ul>
</li>
<li>进程控制块的信息<ul>
<li>进程标识符<ul>
<li>外部标识符PID</li>
<li>内部标识符(端口)</li>
</ul>
</li>
<li>处理机状态<ul>
<li>通用寄存器</li>
<li>指令计数器</li>
<li>程序状态字PSW</li>
<li>用户栈指针</li>
</ul>
</li>
<li>进程调度信息<ul>
<li>进程状态</li>
<li>进程优先级</li>
<li>进程调度所需的其他信息</li>
<li>事件</li>
</ul>
</li>
<li>进程控制信息<ul>
<li>程序和数据的地址</li>
<li>进程同步和通信机制</li>
<li>资源清单</li>
<li>链接指针</li>
</ul>
</li>
<li>进程控制块的组织方式<ul>
<li>线性方式</li>
<li>链接方式</li>
<li>索引方式<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>操作系统内核<ul>
<li>两大功能<ul>
<li>支撑功能<ul>
<li>中断管理</li>
<li>时钟管理</li>
<li>原语操作<ul>
<li>进程的管理，由若干原语（primitive）来执行</li>
</ul>
</li>
</ul>
</li>
<li>资源管理功能<ul>
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ul>
</li>
</ul>
</li>
<li>状态<ul>
<li>系统态，管态，内核态</li>
<li>用户态，目态</li>
</ul>
</li>
</ul>
</li>
<li>进程的创建<ul>
<li>进程的层次结构<ul>
<li>父进程</li>
<li>子进程</li>
</ul>
</li>
<li>引起创建进程的事件<ul>
<li>用户登录</li>
<li>作业调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ul>
</li>
<li>进程的创建过程<ul>
<li>1.申请空白PCB</li>
<li>2.为新进程分配其运行所需的资源</li>
<li>3.初始化进程块PCB</li>
<li>4.如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列</li>
</ul>
</li>
<li>进程的终止<ul>
<li>引起进程终止的事件<ul>
<li>1.正常结束</li>
<li>2.异常结束</li>
<li>3.外界干预</li>
</ul>
</li>
<li>进程的终止过程<ul>
<li>1.根据被终止进程的标识符</li>
</ul>
</li>
</ul>
</li>
<li>进程的阻塞与唤醒<ul>
<li>引起进程阻塞和唤醒的事件<ul>
<li>请求系统服务而未满足</li>
<li>启动某种操作而阻塞当前进程</li>
<li>新数据尚未到达</li>
<li>无新工作可做：系统进程</li>
</ul>
</li>
<li>进程阻塞过程(自己阻塞自己)</li>
<li>进程唤醒过程(系统或其他进程唤醒自己)</li>
</ul>
</li>
<li>进程的挂起与激活<ul>
<li>suspend</li>
<li>active</li>
</ul>
</li>
</ul>
</li>
<li>进程同步<ul>
<li>基本概念<ul>
<li>两种形式的制约关系<ul>
<li>间接相互制约关系<ul>
<li>互斥——竞争</li>
</ul>
</li>
<li>直接相互制约关系<ul>
<li>同步——协作</li>
</ul>
</li>
</ul>
</li>
<li>临界资源</li>
<li>分区<ul>
<li>进入区enter section</li>
<li>临界区critical section</li>
<li>退出区exit section</li>
<li>剩余区remainder section</li>
</ul>
</li>
<li>同步机制应遵循的规则<ul>
<li>1.空闲让进</li>
<li>2.忙则等待</li>
<li>3.有限等待</li>
<li>4.让权等待</li>
</ul>
</li>
</ul>
</li>
<li>进程同步机制<ul>
<li>软件同步机制:都没有解决让权等待，而且部分方法还会产生死锁的情况</li>
<li>硬件同步机制<ul>
<li>关中断</li>
<li>利用Test-and-Set指令实现互斥</li>
<li>利用swap指令实现进程互斥</li>
</ul>
</li>
<li>信号量机制<ul>
<li>整型信号量</li>
<li>记录型信号量<ul>
<li>由于整型信号量没有遵循让权等待原则，记录型允许负数，即阻塞链表</li>
</ul>
</li>
<li>AND型信号量</li>
<li>信号量集<ul>
<li>理解:AND型号量的wait和signal仅能对信号施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。当一次需要N个单位时，便要进行N次wait操作，这显然是低效的，甚至会增加死锁的概率。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类临界资源时，在每次分配前，都必须测试资源数量，判断是否大于可分配的下限值，决定是否予以分配</li>
<li>操作<ul>
<li>Swait(S1，t1，d1…Sn，tn，dn)</li>
<li>Ssignal(S1，d1…Sn，dn)</li>
</ul>
</li>
<li>特殊情况</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>经典进程的同步问题<ul>
<li>生产者–消费者问题</li>
<li>哲学家进餐问题</li>
<li>读者–写者问题<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3></li>
</ul>
</li>
</ul>
</li>
<li>进程通信是指进程之间的信息交换，又称低级进程通信</li>
<li>进程通信的类型<ul>
<li>共享存储器系统<ul>
<li>基于共享数据结构的通信方式<ul>
<li>生产者和消费者</li>
</ul>
</li>
<li>基于共享存储区的通信方式<ul>
<li>高级通信</li>
</ul>
</li>
</ul>
</li>
<li>管道通信系统(pipe)<ul>
<li>高级通信</li>
</ul>
</li>
<li>消息传递系统<ul>
<li>高级通信</li>
<li>方式分类<ul>
<li>直接通信</li>
<li>间接通信</li>
</ul>
</li>
</ul>
</li>
<li>客服机–服务器系统</li>
</ul>
</li>
<li>消息传递通信的实现方式<ul>
<li>直接消息传递系统</li>
<li>信箱通信</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬取qosmos网站信息</title>
    <url>/2020/04/27/python%E7%88%AC%E5%8F%96qosmos%E7%BD%91%E7%AB%99%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h1 id="页面数据分析"><a href="#页面数据分析" class="headerlink" title="页面数据分析"></a>页面数据分析</h1><p>获取网站页面信息，首先确定数据位置：<br><img src="/2020/04/27/python爬取qosmos网站信息/proto-list.png" alt="list_pos"></p>
<p>提取列表标签下整个数据块：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取列表信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_host_info_list</span><span class="params">(source)</span>:</span></span><br><span class="line">    host_info_list = re.findall(<span class="string">'(div id="protocol-list"&gt;.*?&lt;/div&gt;)'</span>, source, re.S)</span><br><span class="line">    print(host_info_list)</span><br><span class="line">    <span class="keyword">return</span> host_info_list</span><br></pre></td></tr></table></figure></p>
<p>处理数据块内部数据，分析<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![html](./python爬取qosmos网站信息/html.png)</span><br><span class="line"></span><br><span class="line">通过对标签```goToProtocolRecord```搜索获取对应值：</span><br><span class="line">```python</span><br><span class="line"># 获取具体信息</span><br><span class="line">def get_host_info(host_info):</span><br><span class="line">    ret = re.search(&apos;&lt;a onclick=&quot;goToProtocolRecord(.*?)&lt;&apos;, host_info)</span><br><span class="line">    if ret is None:</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">    else:</span><br><span class="line">        host_name = str(ret.group(1))</span><br><span class="line"></span><br><span class="line">    ret2 = re.search(&apos;span class=&quot;en&quot;&gt;(.*?)&lt;&apos;, host_info)</span><br><span class="line">    if ret2 is None:</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">    else:</span><br><span class="line">        host_desc = str(ret2.group(1))</span><br><span class="line"></span><br><span class="line">    return host_name+&apos; : &apos;+host_desc</span><br></pre></td></tr></table></figure></p>
<p>以上是对一个页面内容进行提取，但需要获取多页面的数据时:<br><img src="/2020/04/27/python爬取qosmos网站信息/page.png" alt="page_pos"><br>就要构造url进行遍历访问：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_page</span><span class="params">(url, total_page)</span>:</span></span><br><span class="line">    cur_page = int(re.search(<span class="string">'index_.*?_(\d)*'</span>, url).group(<span class="number">1</span>))</span><br><span class="line">    all_pages = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(cur_page, total_page + <span class="number">1</span>):</span><br><span class="line">        all_pages.append(re.sub(<span class="string">'_\d'</span>, <span class="string">'index_%s'</span> % i, url, re.S))</span><br><span class="line">    print(all_pages)</span><br><span class="line">    <span class="keyword">return</span> all_pages</span><br></pre></td></tr></table></figure></p>
<h1 id="url-请求的过程"><a href="#url-请求的过程" class="headerlink" title="url 请求的过程"></a>url 请求的过程</h1><p>用request进行请求访问，获取应答数据：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    headers = &#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) '</span></span><br><span class="line">                        <span class="string">'Chrome/51.0.2704.63 Safari/537.36'</span>&#125;</span><br><span class="line">    req = urllib.request.Request(url=url,headers=headers)</span><br><span class="line">    <span class="keyword">with</span> request.urlopen(req) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    time.sleep(<span class="number">0.01</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></p>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="/2020/04/27/python爬取qosmos网站信息/result.png" alt="result"></p>
<p>也可以使用BeautifulSoup，进行request访问后，使用BeautifulSoup提取<td class="protos-colum">后面的所有a标签的内容，tag.string为协议的名称，tag[‘desc’]为protocol的描述。返回的是一个生成器。</td></p>
<p>代码：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">'按分类爬取web info'</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'hj he'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取列表信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_host_info_list</span><span class="params">(source)</span>:</span></span><br><span class="line">    host_info_list = re.findall(<span class="string">'(div id="protocol-list"&gt;.*?&lt;/div&gt;)'</span>, source, re.S)</span><br><span class="line">    print(host_info_list)</span><br><span class="line">    <span class="keyword">return</span> host_info_list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取具体信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_host_info</span><span class="params">(host_info)</span>:</span></span><br><span class="line">    ret = re.search(<span class="string">'&lt;a onclick="goToProtocolRecord(.*?)&lt;'</span>, host_info)</span><br><span class="line">    <span class="keyword">if</span> ret <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        host_name = str(ret.group(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    ret2 = re.search(<span class="string">'span class="en"&gt;(.*?)&lt;'</span>, host_info)</span><br><span class="line">    <span class="keyword">if</span> ret2 <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        host_desc = str(ret2.group(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> host_name+<span class="string">' : '</span>+host_desc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    headers = &#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) '</span></span><br><span class="line">                        <span class="string">'Chrome/51.0.2704.63 Safari/537.36'</span>&#125;</span><br><span class="line">    req = urllib.request.Request(url=url,headers=headers)</span><br><span class="line">    <span class="keyword">with</span> request.urlopen(req) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    time.sleep(<span class="number">0.01</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_page</span><span class="params">(url, total_page)</span>:</span></span><br><span class="line">    cur_page = int(re.search(<span class="string">'index_.*?_(\d)*'</span>, url).group(<span class="number">1</span>))</span><br><span class="line">    all_pages = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(cur_page, total_page + <span class="number">1</span>):</span><br><span class="line">        all_pages.append(re.sub(<span class="string">'_\d'</span>, <span class="string">'index_%s'</span> % i, url, re.S))</span><br><span class="line">    print(all_pages)</span><br><span class="line">    <span class="keyword">return</span> all_pages</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text_read</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="comment"># Try to read a txt file and return a list.Return [] if there was a mistake.</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        file = open(filename,<span class="string">'r'</span>)</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        error = []</span><br><span class="line">        <span class="keyword">return</span> error</span><br><span class="line">    content = file.readlines()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(content)):</span><br><span class="line">        content[i] = content[i][:len(content[i])<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    file.close()</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_info</span><span class="params">(info)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'qosmos_falmily_res.txt'</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> info:</span><br><span class="line">            f.write(i + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getUrl_multiTry</span><span class="params">(url)</span>:</span></span><br><span class="line">    user_agent = <span class="string">'"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2125.122 Safari/539.36"'</span></span><br><span class="line">    headers = &#123;<span class="string">'User-Agent'</span>: user_agent&#125;</span><br><span class="line">    maxTryNum = <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> tries <span class="keyword">in</span> range(maxTryNum):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            req = urllib.request.Request(url, headers=headers)</span><br><span class="line">            <span class="keyword">with</span> request.urlopen(req) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="keyword">return</span> f.read()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> tries &lt; (maxTryNum - <span class="number">1</span>):</span><br><span class="line">                print(url)</span><br><span class="line">                print(<span class="string">'request again\n'</span>)</span><br><span class="line">                <span class="string">'''continue'''</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#logging.error("Has tried %d times to access url %s, all failed!", maxTryNum, url)</span></span><br><span class="line">                print(<span class="string">'except:'</span>, e)</span><br><span class="line">                <span class="string">'''break'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    familyList = text_read(<span class="string">'qosmos_family.txt'</span>)</span><br><span class="line">    <span class="keyword">for</span> family <span class="keyword">in</span> familyList:</span><br><span class="line">        familyUrl = <span class="string">"https://protobook.qosmos.com/browse_protocols.html?type=Family&amp;value="</span> + family</span><br><span class="line">        info_list = []</span><br><span class="line">        <span class="comment">#url = countryUrl + ".html"</span></span><br><span class="line">        data = getUrl_multiTry(familyUrl)</span><br><span class="line"></span><br><span class="line">        host_info_list = get_host_info_list(data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> host_info <span class="keyword">in</span> host_info_list:</span><br><span class="line">            info_list.append(family+<span class="string">":"</span>+get_host_info(host_info))</span><br><span class="line">        save_info(info_list)</span><br><span class="line">        <span class="comment">#print(info_list)</span></span><br><span class="line">        <span class="keyword">del</span> info_list[:]</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>Excel-页合并</title>
    <url>/2020/03/16/Excel-%E9%A1%B5%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h1 id="Excel—-合并多个-Excel-工作簿至一个工作簿中的工作表"><a href="#Excel—-合并多个-Excel-工作簿至一个工作簿中的工作表" class="headerlink" title="Excel—-合并多个 Excel 工作簿至一个工作簿中的工作表"></a>Excel—-合并多个 Excel 工作簿至一个工作簿中的工作表</h1><h2 id="多个工作簿合并到一个工作簿"><a href="#多个工作簿合并到一个工作簿" class="headerlink" title="多个工作簿合并到一个工作簿"></a>多个工作簿合并到一个工作簿</h2><p>在由多个工作簿合并到一个工作表之前，需要把多个工作簿合并到一个工作簿。</p>
<p>1、新建一个工作薄，将其命名为合并后的名字，例如叫做：汇总工作簿。<br>2、打开此工作簿：“汇总工作簿”<br>3、在“汇总工作簿”下任一个工作表标签上点击右键，选择“查看代码”。<br>4、在打开的VBA编辑窗口中粘贴以下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sub 工作薄间工作表合并()</span><br><span class="line">Dim FileOpen</span><br><span class="line">Dim X As Integer</span><br><span class="line">Application.ScreenUpdating = False</span><br><span class="line">FileOpen = Application.GetOpenFilename(FileFilter:=&quot;Microsoft Excel文件(.xlsx),.xlsx&quot;, MultiSelect:=True, Title:=&quot;合并工作薄&quot;)</span><br><span class="line">X = 1</span><br><span class="line">While X &lt;= UBound(FileOpen)</span><br><span class="line">Workbooks.Open Filename:=FileOpen(X)</span><br><span class="line">Sheets().Move After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count)</span><br><span class="line">X = X + 1</span><br><span class="line">Wend</span><br><span class="line">ExitHandler:</span><br><span class="line">Application.ScreenUpdating = True</span><br><span class="line">Exit Sub</span><br><span class="line">errhadler:</span><br><span class="line">MsgBox Err.Description</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure></p>
<p>5、关闭该VBA编辑窗口<br>6、在Excel中，开发工具—-宏,选“工作薄间工作表合并”,然后“执行”。<br>7、在打开的对话窗口中，选择你要合并的多个工作薄。<br>8、等待运行。而后就OK了。<br>9、打开名为“汇总工作簿”的Excel文件，我们就能看到多个其他工作簿以多个Sheet页的形式合并到了这一个工作簿中。</p>
<h2 id="多个工作表合成一个工作表"><a href="#多个工作表合成一个工作表" class="headerlink" title="多个工作表合成一个工作表"></a>多个工作表合成一个工作表</h2><p>在“汇总工作簿”工作簿中，有很多个Sheet页，我们的最终目的是把这多个Sheet页合并到一个Sheet页的多行。其操作办法如下：<br>1、在“汇总工作簿”中，新建一个sheet页。<br>2、在新建的sheet标签上单击右键，选择“查看代码”<br>3、在打开的VBA编辑窗口中粘贴以下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sub 合并当前工作簿下的所有工作表()</span><br><span class="line">Application.ScreenUpdating = False</span><br><span class="line">For j = 1 To Sheets.Count</span><br><span class="line">If Sheets(j).Name &lt;&gt; ActiveSheet.Name Then</span><br><span class="line">X = Range(&quot;A65536&quot;).End(xlUp).Row + 1</span><br><span class="line">Sheets(j).UsedRange.Copy Cells(X, 1)</span><br><span class="line">End If</span><br><span class="line">Next</span><br><span class="line">Range(&quot;B1&quot;).Select</span><br><span class="line">Application.ScreenUpdating = True</span><br><span class="line">MsgBox &quot;当前工作簿下的全部工作表已经合并完毕！&quot;, vbInformation, &quot;提示&quot;</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure></p>
<p>4、关闭该VBA编辑窗口<br>5、在Excel中，开发工具—-宏,选“合并当前工作簿下的所有工作表”,然后“执行”。<br>6、等待运行，而后就OK了。</p>
<h2 id="目录生成"><a href="#目录生成" class="headerlink" title="目录生成"></a>目录生成</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sub getAllWorkSheets()</span><br><span class="line">&apos; 得到所有的sheet页名称，并加上超连接</span><br><span class="line">    totalNum = Worksheets.Count</span><br><span class="line">    Sheet1.Activate</span><br><span class="line">    Range(&quot;a:a&quot;).Select</span><br><span class="line">   Selection.NumberFormatLocal = &quot;@&quot;</span><br><span class="line"></span><br><span class="line">&apos;从2开始就是不带&quot;目录&quot;Sheet页，如果要带，则从1开始</span><br><span class="line">    For index_i = 1 To totalNum</span><br><span class="line">        sheetName = Worksheets(index_i).Name</span><br><span class="line">        Cells(index_i, 1) = sheetName</span><br><span class="line">        tar_sheet = &quot;&apos;&quot; &amp; sheetName &amp; &quot;&apos;&quot;</span><br><span class="line">        Cells(index_i, 1).Select</span><br><span class="line">        ActiveSheet.Hyperlinks.Add Anchor:=Selection, Address:=&quot;&quot;, SubAddress:= _</span><br><span class="line">        tar_sheet &amp; &quot;!A1&quot;, TextToDisplay:=sheetName</span><br><span class="line">    Next index_i</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure>
<h2 id="目录及返回"><a href="#目录及返回" class="headerlink" title="目录及返回"></a>目录及返回</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function WorkSheetExists(oWB As Workbook, ByVal sWkName As String) As Boolean</span><br><span class="line">    &apos;判断指定名称的工作表是否存在</span><br><span class="line">    &apos;Demo</span><br><span class="line">    &apos;oWB为具体的工作簿,sWkName为工作表的名称,结果返回True表示存在</span><br><span class="line">    On Error Resume Next</span><br><span class="line">    Dim oWK As Worksheet</span><br><span class="line">    Set oWK = oWB.Worksheets(sWkName)</span><br><span class="line">    &apos;如果出错表示不存在指定名称的工作表</span><br><span class="line">    If Err.Number &lt;&gt; 0 Then</span><br><span class="line">        WorkSheetExists = False</span><br><span class="line">    Else</span><br><span class="line">        WorkSheetExists = True</span><br><span class="line">    End If</span><br><span class="line">    Err.Clear</span><br><span class="line">End Function</span><br><span class="line">Sub Demo()</span><br><span class="line">    Excel.Application.DisplayAlerts = False</span><br><span class="line">    On Error Resume Next</span><br><span class="line">    Dim oWK As Worksheet</span><br><span class="line">    Dim oWB As Workbook</span><br><span class="line">    Dim oSp As Shape</span><br><span class="line">    Set oWB = Excel.ActiveWorkbook</span><br><span class="line">   If WorkSheetExists(oWB, &quot;导航目录&quot;) = False Then</span><br><span class="line">        Set oWK = oWB.Worksheets.Add(Excel.Worksheets(1))</span><br><span class="line">        oWK.Name = &quot;导航目录&quot;</span><br><span class="line">        oWK.Range(&quot;a1&quot;) = &quot;目录&quot;</span><br><span class="line">   Else</span><br><span class="line">        Set oWK = oWB.Worksheets(&quot;导航目录&quot;)</span><br><span class="line">        oWK.Delete</span><br><span class="line">        Set oWK = oWB.Worksheets.Add(Excel.Worksheets(1))</span><br><span class="line">        oWK.Name = &quot;导航目录&quot;</span><br><span class="line">        oWK.Range(&quot;a1&quot;) = &quot;目录&quot;</span><br><span class="line">   End If</span><br><span class="line">   Dim oWK1 As Worksheet</span><br><span class="line">   i = 2</span><br><span class="line">   For Each oWK1 In oWB.Worksheets</span><br><span class="line">        Dim oRng As Range</span><br><span class="line">        If oWK1.Name &lt;&gt; oWK.Name Then</span><br><span class="line">            oWK1.Shapes(&quot;超链接&quot;).Delete</span><br><span class="line">            Set oRng = oWK.Range(&quot;a&quot; &amp; i)</span><br><span class="line">            sAddress = oWK1.Range(&quot;a1&quot;).Address(, , , True)</span><br><span class="line">            oWK.Hyperlinks.Add oRng, &quot;&quot;, sAddress, , oWK1.Name</span><br><span class="line">            Set oSp = oWK1.Shapes.AddShape(msoShapeBalloon, 0, 0, 50, 30)</span><br><span class="line">            oWK1.Hyperlinks.Add oSp, &quot;&quot;, oWK.Range(&quot;a1&quot;).Address(, , , True), , &quot;&quot;</span><br><span class="line">            oSp.Name = &quot;超链接&quot;</span><br><span class="line">            oSp.TextFrame2.TextRange.Text = &quot;返回&quot;</span><br><span class="line">            i = i + 1</span><br><span class="line">        End If</span><br><span class="line">   Next</span><br><span class="line">   Excel.Application.DisplayAlerts = True</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure>
<h2 id="按列中条件拆封成多个excel文件"><a href="#按列中条件拆封成多个excel文件" class="headerlink" title="按列中条件拆封成多个excel文件"></a>按列中条件拆封成多个excel文件</h2><p>按某A列中分类拆封成多个单独的excel文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sub 拆分成多个文件()</span><br><span class="line"></span><br><span class="line">    &apos;输入用户想要拆分的工作表</span><br><span class="line">    Dim sheet_name</span><br><span class="line">    sheet_name = Application.InputBox(&quot;请输入拆分工作表的名称(如Sheet1)：&quot;)</span><br><span class="line">    Worksheets(sheet_name).Select</span><br><span class="line"></span><br><span class="line">    &apos;输入获取拆分需要的条件列</span><br><span class="line">    Dim col_name</span><br><span class="line">    col_name = Application.InputBox(&quot;请输入拆分依据的列号(如A):&quot;)</span><br><span class="line"></span><br><span class="line">    &apos;输入拆分的开始行，要求输入的是数字</span><br><span class="line">    Dim start_row As Integer</span><br><span class="line">    start_row = Application.InputBox(prompt:=&quot;请输入拆分的开始行(如2):&quot;, Type:=1)</span><br><span class="line"></span><br><span class="line">    &apos;暂停屏幕更新</span><br><span class="line">    Application.ScreenUpdating = False</span><br><span class="line"></span><br><span class="line">    &apos;工作表的总行数</span><br><span class="line">    Dim end_row</span><br><span class="line">    end_row = Worksheets(sheet_name).Range(&quot;A65536&quot;).End(xlUp).Row</span><br><span class="line"></span><br><span class="line">    &apos;遍历计算所有拆分表，每个拆分表的格式为&quot;表名称,表行数&quot;</span><br><span class="line">    &apos;对于二维数组，ReDim只能扩充最后一维，因此sheet_map行不变，扩充列</span><br><span class="line">    Dim sheet_map(), sheet_index</span><br><span class="line">    ReDim sheet_map(1, 0)</span><br><span class="line">    sheet_map(0, 0) = Range(col_name &amp; start_row).Value</span><br><span class="line">    sheet_map(1, 0) = 1</span><br><span class="line">    sheet_index = 0</span><br><span class="line"></span><br><span class="line">    With Worksheets(sheet_name)</span><br><span class="line">        Dim row_count, temp, i</span><br><span class="line">        row_count = 0</span><br><span class="line">        For i = start_row + 1 To end_row</span><br><span class="line">            temp = Range(col_name &amp; i).Value</span><br><span class="line">            If temp = Range(col_name &amp; (i - 1)).Value Then</span><br><span class="line">                sheet_map(1, sheet_index) = sheet_map(1, sheet_index) + 1</span><br><span class="line">            Else</span><br><span class="line">                ReDim Preserve sheet_map(1, sheet_index + 1)</span><br><span class="line">                sheet_index = sheet_index + 1</span><br><span class="line">                sheet_map(0, sheet_index) = temp</span><br><span class="line">                sheet_map(1, sheet_index) = 1</span><br><span class="line">            End If</span><br><span class="line">        Next</span><br><span class="line">    End With</span><br><span class="line"></span><br><span class="line">    &apos;根据前面计算的拆分表，拆分成单个文件</span><br><span class="line">    Dim row_index</span><br><span class="line">    row_index = start_row</span><br><span class="line">    For i = 0 To sheet_index</span><br><span class="line">        Workbooks.Add</span><br><span class="line">        &apos;创建最终数据文件夹</span><br><span class="line">        Dim dir_name</span><br><span class="line">        dir_name = ThisWorkbook.Path &amp; &quot;\拆分出的表格\&quot;</span><br><span class="line">        If Dir(dir_name, vbDirectory) = &quot;&quot; Then</span><br><span class="line">            MkDir (dir_name)</span><br><span class="line">        End If</span><br><span class="line">        &apos;创建新工作簿</span><br><span class="line">        Dim workbook_path</span><br><span class="line">        workbook_path = ThisWorkbook.Path &amp; &quot;\拆分出的表格\&quot; &amp; sheet_map(0, i) &amp; &quot;.xls&quot;</span><br><span class="line">        ActiveWorkbook.SaveAs Filename:=workbook_path, FileFormat:=-4143</span><br><span class="line">        ActiveSheet.Name = sheet_map(0, i)</span><br><span class="line">        &apos;激活当前工作簿，ThisWorkbook表示当前跑代码的工作簿</span><br><span class="line">        ThisWorkbook.Activate</span><br><span class="line"></span><br><span class="line">        &apos;拷贝条目数据(即最前面不需要拆分的数据行)</span><br><span class="line">        Dim row_range</span><br><span class="line">        row_range = 1 &amp; &quot;:&quot; &amp; (start_row - 1)</span><br><span class="line">        Worksheets(sheet_name).Rows(row_range).Copy</span><br><span class="line">        Workbooks(sheet_map(0, i) &amp; &quot;.xls&quot;).Sheets(1).Range(&quot;A1&quot;).PasteSpecial</span><br><span class="line">        &apos;拷贝拆分表的专属数据</span><br><span class="line">        row_range = row_index &amp; &quot;:&quot; &amp; (row_index + sheet_map(1, i) - 1)</span><br><span class="line">        Worksheets(sheet_name).Rows(row_range).Copy</span><br><span class="line">        Workbooks(sheet_map(0, i) &amp; &quot;.xls&quot;).Sheets(1).Range(&quot;A&quot; &amp; start_row).PasteSpecial</span><br><span class="line">        row_index = row_index + sheet_map(1, i)</span><br><span class="line"></span><br><span class="line">        &apos;保存文件</span><br><span class="line">        Workbooks(sheet_map(0, i) &amp; &quot;.xls&quot;).Close SaveChanges:=True</span><br><span class="line">    Next</span><br><span class="line"></span><br><span class="line">    &apos;进行屏幕更新</span><br><span class="line">    Application.ScreenUpdating = True</span><br><span class="line"></span><br><span class="line">    MsgBox &quot;拆分工作表完成&quot;</span><br><span class="line"></span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Daily Work</category>
      </categories>
      <tags>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear Algebra with Application</title>
    <url>/2020/02/24/Linear-Algebra-with-Application/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.nctucs.org/study/linear/steven/instructorsmanualleon7edpart3.pdf" target="_blank" rel="noopener">Linear Algebra with application 7th answer - Steven J.Leon</a></p>
</blockquote>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>Day3:多元梯度下降法-学习率a</title>
    <url>/2020/02/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0day3/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/108247059" target="_blank" rel="noopener">吴恩达 AI 完整课程资源全汇总下载!</a></p>
</blockquote>
<h2 id="多元梯度下降法"><a href="#多元梯度下降法" class="headerlink" title="多元梯度下降法"></a>多元梯度下降法</h2><ul>
<li>多元梯度下降法：使用梯度下降法来处理多变量线性回归(多元线性回归)。</li>
</ul>
<h2 id="多元梯度下降运算中的实用技巧"><a href="#多元梯度下降运算中的实用技巧" class="headerlink" title="多元梯度下降运算中的实用技巧"></a>多元梯度下降运算中的实用技巧</h2><p>（均用于优化梯度下降，最终目的均是使下降速度变得更快）</p>
<h3 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h3><ul>
<li>特征缩放的作用：使梯度下降的速度变得更快，则收敛所需的迭代次数便更少，这就是特征缩放。</li>
</ul>
<h4 id="首先讨论什么情况下需要特征缩放"><a href="#首先讨论什么情况下需要特征缩放" class="headerlink" title="首先讨论什么情况下需要特征缩放"></a>首先讨论什么情况下需要特征缩放</h4><ol>
<li>比如你有一个机器学习问题，这个问题有多个特征，如果你能确保这些特征都处在一个相近的范围内，那么这样梯度下降法就能更快地收敛。具体地说，假如你有一个具有两个特征的问题，其中x_1是房屋面积大小，他的取值范围在0到2000之间。x_2是卧室数量，他的取值范围在1到5之间。</li>
<li>代价函数J(θ)是一个关于参数θ0、θ1、θ2的函数，但暂时忽略θ0，并假设这个函数的变量就只有θ1、θ2。但如果x_1(房屋面积大小)的取值范围远远大于x_2(卧室数量)的取值范围的话，那么最终画出的代价函数J(θ)的等值线就会呈现出如下图，一种非常歪斜并且椭圆的形状。实际2000比5(房屋面积大小比卧室数量)的比例，会让这个椭圆更加瘦长，所以这个又瘦又高的椭圆形等值线图就是如下图这些非常高大细长的椭圆形，从而构成了代价函数J(θ)的等值线。        </li>
<li>如果你在这种代价函数上运行梯度下降的话，你的梯度最终可能需要花很长一段时间，并且可能会来回波动，然后会经过很长时间最终才收敛到全局的最小值。如果这些等值线还更夸张一些的话，那么可以把它画的更细更长，可能比这还更夸张一点，结果就是梯度下降的过程可能更加缓慢，并且反复来回震荡，需要花费很长时间才找到一条通往全局的最小值的路线。在这样的情况下，一种有效的方法就是进行特征缩放。</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol>
<li>更一般的，在执行特征缩放时的通常目的是：将特征的取值范围约束到-1到+1的范围之内。比如说特征值x_0总是等于1，那么这已经在-1到+1的范围之内。但对于其他特征值可能需要通过除以不同的数来让他们处于这同一范围之内。</li>
<li>-1和1这两个数字并不是太重要。比如说有一个特征值x_1的取值范围在0到3之间，非常接近-1到+1的范围之内这没问题。如果还有另外一个特征值x_2的取值范围在-2到+0.5之间，这也非常接近-1到+1的范围之内这也没问题。但如果说有另外一个特征值x_3它的取值范围在-100到+100之间，那么它和-1到+1的范围就有很多差异了，所以这个便是范围不是太合适的特征。</li>
<li>如果特征值在非常非常小的范围之内的话，比如说一个特征值x_4的取值范围在-0.0001到+0.0001之间的话，那么这便是比-1到+1小得多的范围，因此同样认为这个特征值的范围不合适。所以可能认可的范围也许可以大于+1或者小于+1，但是也别相差太大，比如+100，也别太小，比如刚才所述的+0.001。</li>
<li>可以一般这么考虑，特征值的取值范围在-3到+3的范围之内是可以接受的，如果某个特征值的取值范围大于-3到+3的范围的话，就需要注意了。比如某个特征值的取值范围在-1/3到+1/3之间 或 0到+1/3之间 或 -1/3到0之间的话，可以认为都可以接受的。比如前面所述的特征值x_4的取值范围在-0.0001到+0.0001之间就需要重新考虑了。</li>
</ol>
<h2 id="学习率a"><a href="#学习率a" class="headerlink" title="学习率a"></a>学习率a</h2><ol>
<li>如果学习率a过小，可能收敛的速度会很慢，则造成梯度下降算法的迭代次数需要非常多次才能到达最低点。</li>
<li>如果学习率a过大的话，可能收敛的速度过于太快，则造成代价函数J(θ)值可能不会在每次迭代之后都下降，甚至反而可能在上升，最终无法收敛。</li>
<li><p>如果学习率a过大的话，也可能会出现收敛的速度很慢，但更加常见的是每次迭代之后代价函数J(θ)值都并不会下降。</p>
</li>
<li><p>解决方法和步骤：</p>
<ul>
<li>在运行梯度下降算法时，通常可以尝试一系列学习率a值，比如说每隔10倍取一个值，即0.001-&gt;0.01-&gt;0.1-&gt;1-&gt;…等。然后对于这些不同的学习率a值，绘制代价函数J(θ)随迭代次数不断增加而J(θ)值不断变化的曲线图。最终选择一个可以使代价函数J(θ)值快速下降的学习率a值。</li>
<li>事实上，通常并不仅可以是每隔10倍取一个值作为学习率a值，还可以每隔3倍取一个值作为学习率a值.比如 0.001-&gt;0.003-&gt;0.01-&gt;0.03-&gt;0.1-&gt;0.3-&gt;1-&gt;…等。可以这么看，0.001-&gt;0.003增加3倍，0.003-&gt;0.01则大约增加3倍多一点，而0.01-&gt;0.03又增加3倍，而0.03-&gt;0.1则又大约增加3倍多一点，以此类推。</li>
</ul>
</li>
<li>所以可以尝试一系列学习率a值，那么便可以找到最小值(比如0.001)，再找到另外一个最大值(比如1)，然后可以取最大值或者比最大值略小一些的比较合理的值，通常这样做便可以为梯度下降算法找到一个合适的学习率a。</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Day2:梯度下降</title>
    <url>/2020/02/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0day2/</url>
    <content><![CDATA[<h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><blockquote>
<p>主要目的是通过迭代找到目标函数的最小值，或者收敛到最小值。—-也可参考《<a href="https://arxiv.org/pdf/1609.04747.pdf" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a>》</p>
</blockquote>
<p>基于day1的代价函数，梯度下降就是找到一个方法使得 <strong>J</strong> 快速由峰值到峰底，例如：<br><img src="/2020/02/18/机器学习day2/gradient_descent.png" alt="gradient_descent"><br>类似下山场景。 —《<a href="https://storage.googleapis.com/supplemental_media/udacityu/315142919/Gradient%20Descent.pdf" target="_blank" rel="noopener">Gradient Descent - Problem of Hiking Down a Mountain</a>》</p>
<h3 id="算法表示"><a href="#算法表示" class="headerlink" title="算法表示"></a>算法表示</h3><p><img src="/2020/02/18/机器学习day2/gradient_descent_algorithm.png" alt="gradient_descent_algorithm"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义数据集和学习率</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># Size of the points dataset.</span></span><br><span class="line">m = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Points x-coordinate and dummy value (x0, x1).</span></span><br><span class="line">X0 = np.ones((m, <span class="number">1</span>))</span><br><span class="line">X1 = np.arange(<span class="number">1</span>, m+<span class="number">1</span>).reshape(m, <span class="number">1</span>)</span><br><span class="line">X = np.hstack((X0, X1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Points y-coordinate</span></span><br><span class="line">y = np.array([</span><br><span class="line">    <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">11</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">21</span></span><br><span class="line">]).reshape(m, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#--------------------------------------------------</span></span><br><span class="line"><span class="comment">#以矩阵向量的形式定义代价函数和代价函数的梯度</span></span><br><span class="line"><span class="comment"># The Learning Rate alpha.</span></span><br><span class="line">alpha = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_function</span><span class="params">(theta, X, y)</span>:</span></span><br><span class="line">    <span class="string">'''Error function J definition.'''</span></span><br><span class="line">    diff = np.dot(X, theta) - y</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.</span>/<span class="number">2</span>*m) * np.dot(np.transpose(diff), diff)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_function</span><span class="params">(theta, X, y)</span>:</span></span><br><span class="line">    <span class="string">'''Gradient of the function J definition.'''</span></span><br><span class="line">    diff = np.dot(X, theta) - y</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.</span>/m) * np.dot(np.transpose(X), diff)</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------------------------------</span></span><br><span class="line"><span class="comment"># 梯度下降迭代计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span><span class="params">(X, y, alpha)</span>:</span></span><br><span class="line">    <span class="string">'''Perform gradient descent.'''</span></span><br><span class="line">    theta = np.array([<span class="number">1</span>, <span class="number">1</span>]).reshape(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    gradient = gradient_function(theta, X, y)</span><br><span class="line">    <span class="comment">#当梯度小于1e-5时，说明已经进入了比较平滑的状态，类似于山谷的状态</span></span><br><span class="line">    <span class="comment">#这时候再继续迭代效果也不大了，所以这个时候可以退出循环</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> np.all(np.absolute(gradient) &lt;= <span class="number">1e-5</span>):</span><br><span class="line">        theta = theta - alpha * gradient</span><br><span class="line">        gradient = gradient_function(theta, X, y)</span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line"></span><br><span class="line">optimal = gradient_descent(X, y, alpha)</span><br><span class="line">print(<span class="string">'optimal:'</span>, optimal)</span><br><span class="line">print(<span class="string">'error function:'</span>, error_function(optimal, X, y)[<span class="number">0</span>,<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">optimal: [[0.51583286]</span><br><span class="line"> [0.96992163]]</span><br><span class="line">error function: 405.9849624932369</span><br></pre></td></tr></table></figure></p>
<p><img src="/2020/02/18/机器学习day2/result.png" alt="result"><br>拟合结果为图中直线。</p>
<p>参考:</p>
<ul>
<li><a href="https://www.jianshu.com/p/c7e642877b0e" target="_blank" rel="noopener">深入浅出—梯度下降法及其实现</a></li>
<li><a href="https://arxiv.org/pdf/1609.04747.pdf" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a></li>
<li><a href="https://storage.googleapis.com/supplemental_media/udacityu/315142919/Gradient%20Descent.pdf" target="_blank" rel="noopener">Gradient Descent - Problem of Hiking Down a Mountain</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Day1:监督学习-无监督学习-代价函数</title>
    <url>/2020/02/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0day1/</url>
    <content><![CDATA[<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>代价函数衡量的是模型预测值h(θ) 与标准答案y之间的差异，所以总的代价函数J是h(θ)和y的函数，即J=f(h(θ), y)。又因为y都是训练样本中给定的，h(θ)由θ决定，所以，最终还是模型参数θ的改变导致了J的改变。对于不同的θ，对应不同的预测值h(θ)，也就对应着不同的代价函数J的取值。变化过程为：<code>θ−−&gt;h(θ)−−&gt;J(θ)</code>。θ引起了h(θ)的改变，进而改变了J(θ)的取值。</p>
<p>在线性回归中，最常用的是均方误差(Mean squared error)，具体形式为：</p>
<ul>
<li>假设函数 Hypothesis：<script type="math/tex; mode=display">h_{\theta }(x) = \theta _{0}+\theta _{1}x</script></li>
<li>参数 Parameters:<script type="math/tex; mode=display">\theta _{0},\theta _{1}</script></li>
<li>代价函数 Cost Function：<script type="math/tex; mode=display">J(\theta _{0},\theta _{1})= \frac{1}{2m}\cdot\sum_{i=1}^{m}(h_{\theta }(x^{i})-y^{i})^{2}</script></li>
<li><p>目的 Goal:</p>
<script type="math/tex; mode=display">\texttt{minimize } J(\theta _{0},\theta _{1})</script><p>得到均方误差。</p>
<ul>
<li>举个简单的例子，假设 $ \theta _{0} = 0 $：有训练样本{(0, 0), (1, 1), (2, 2), (4, 4)}，即4对训练样本，每个样本对中第1个数表示x的值，第2个数表示y的值。这几个点很明显都是y=x这条直线上的点。如下左图： <img src="/2020/02/17/机器学习day1/ML_cost_function.png" alt="ML_cost_function"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Day0:Tensorflow-gpu安装问题</title>
    <url>/2020/02/16/Tensorflow-gpu%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Tensorflow-gpu安装问题"><a href="#Tensorflow-gpu安装问题" class="headerlink" title="Tensorflow-gpu安装问题"></a>Tensorflow-gpu安装问题</h1><h2 id="Anaconda安装"><a href="#Anaconda安装" class="headerlink" title="Anaconda安装"></a>Anaconda安装</h2><p>先安装ANACONDA，安装好ANACONDA后，会自动添加环境，检查是否正确。<br><img src="/2020/02/16/Tensorflow-gpu安装问题/anaconda_path.png" alt="Anaconda"></p>
<h2 id="环境检查"><a href="#环境检查" class="headerlink" title="环境检查"></a>环境检查</h2><p>查看自己电脑的管理中查看GPU型号。<br><img src="/2020/02/16/Tensorflow-gpu安装问题/device.png" alt="EnvCheck"><br>查看显卡是否支持，例如本机器NVIDIA 960M，搜索960M+SPECIFICATION，在官网中即可查看到是否支持CUDA。<br><img src="/2020/02/16/Tensorflow-gpu安装问题/960M.png" alt="960M"></p>
<h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><ul>
<li>【重要】确认CUDA版本与tensorflow-gpu版本间的对应，避免追朔后续各种调试麻烦，本机安装的是是tensorflow_gpu-1.16.0和CUDA10.0匹配方式，cuDNN选用的是7.5，python3.6.9版本。</li>
<li>单独点到CUDA Toolkit Archive里去找10.0，目前最新为10.1</li>
</ul>
<h2 id="安装Tensorflow-gpu"><a href="#安装Tensorflow-gpu" class="headerlink" title="安装Tensorflow-gpu"></a>安装Tensorflow-gpu</h2><h3 id="tensorflow-gpu版本查看"><a href="#tensorflow-gpu版本查看" class="headerlink" title="tensorflow-gpu版本查看"></a>tensorflow-gpu版本查看</h3><p><img src="/2020/02/16/Tensorflow-gpu安装问题/tensorflow_ver.png" alt="tensorflow_ver"><br>目前安装的是1.15版本，安装2.0版本如下，对应CUDA和cuDNN彻底删除后安装成功。</p>
<h2 id="最简单方式安装成功方法"><a href="#最简单方式安装成功方法" class="headerlink" title="最简单方式安装成功方法"></a>最简单方式安装成功方法</h2><ul>
<li><p>安装最新Anaconda，自动添加<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```Anaconda3-2019.10-Windows-x86_64.exe</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>在Anaconda Navigator中create 新的环境，python为3.7<br><img src="/2020/02/16/Tensorflow-gpu安装问题/tf-gpu.png" alt="tf-gpu"></p>
</li>
<li>点击 Open Terminal，conda安装tensorflow-gpu==2.0.0即可。  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conda install tensorflow-gpu==<span class="number">2.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>【注意】Nvidia驱动程序要410.x以上，通过<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```442.19-notebook-win10-64bit-international-dch-whql.exe</span><br></pre></td></tr></table></figure></p>
<p><img src="/2020/02/16/Tensorflow-gpu安装问题/nvidia-smi.png" alt="nvidia-smi"></p>
<h2 id="Tensorflow-gpu性能对比"><a href="#Tensorflow-gpu性能对比" class="headerlink" title="Tensorflow-gpu性能对比"></a>Tensorflow-gpu性能对比</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> tf.device(<span class="string">'/cpu:0'</span>):</span><br><span class="line">	cpu_a = tf.random.normal([<span class="number">1000</span>, <span class="number">1000</span>])</span><br><span class="line">	cpu_b = tf.random.normal([<span class="number">1000</span>, <span class="number">2000</span>])</span><br><span class="line">	print(cpu_a.device, cpu_b.device)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> tf.device(<span class="string">'/gpu:0'</span>):</span><br><span class="line">	gpu_a = tf.random.normal([<span class="number">1000</span>, <span class="number">1000</span>])</span><br><span class="line">	gpu_b = tf.random.normal([<span class="number">1000</span>, <span class="number">2000</span>])</span><br><span class="line">	print(gpu_a.device, gpu_b.device)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cpu_run</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">with</span> tf.device(<span class="string">'/cpu:0'</span>):</span><br><span class="line">		c = tf.matmul(cpu_a, cpu_b)</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gpu_run</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">with</span> tf.device(<span class="string">'/gpu:0'</span>):</span><br><span class="line">		c = tf.matmul(gpu_a, gpu_b)</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line"> </span><br><span class="line"><span class="comment"># warm up</span></span><br><span class="line">cpu_time = timeit.timeit(cpu_run, number=<span class="number">10</span>)</span><br><span class="line">gpu_time = timeit.timeit(gpu_run, number=<span class="number">10</span>)</span><br><span class="line">print(<span class="string">'warmup:'</span>, cpu_time, gpu_time)</span><br><span class="line"> </span><br><span class="line">cpu_time = timeit.timeit(cpu_run, number=<span class="number">10</span>)</span><br><span class="line">gpu_time = timeit.timeit(gpu_run, number=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'run time:'</span>, cpu_time, gpu_time)</span><br></pre></td></tr></table></figure>
<p>本机只有一个GPU，结果如下图。<br><img src="/2020/02/16/Tensorflow-gpu安装问题/gpu_vs_cpu.png" alt="gpu_vs_cpu"></p>
<h2 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h2><p>打开prompt ，一般默认的是base,可以使用conda env list 列出当前系统中存在多少环境，使用activate env_name 来激活你想要使用的环境：<code>activate tf-gpu</code>，然后<code>jupyter notebook</code>进入jupyter notebook。离开则在 Windows 上，终端中输入：<code>deactivate</code></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm Note</title>
    <url>/2019/12/01/Algorithm-Note/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-List</title>
    <url>/2019/07/14/Data-Struction-List-Leetcode/</url>
    <content><![CDATA[<h1 id="LeetCode-234"><a href="#LeetCode-234" class="headerlink" title="LeetCode 234"></a>LeetCode 234</h1><p>请判断一个链表是否为回文链表。</p>
<ul>
<li><p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>解决参照之前练习题：查找中间节点 和 反转列表 应用结合起来：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *p=reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next=head;</span><br><span class="line">        head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *mid =  middleNode(head);</span><br><span class="line">        ListNode *slow = reverseList(mid);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head&amp;&amp;slow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val!=slow-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                head=head-&gt;next;</span><br><span class="line">                slow=slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>shadowsocks</title>
    <url>/2019/02/27/shadowsocks/</url>
    <content><![CDATA[<h1 id="查看及修改ss服务器的端口和密码"><a href="#查看及修改ss服务器的端口和密码" class="headerlink" title="查看及修改ss服务器的端口和密码"></a>查看及修改ss服务器的端口和密码</h1><ol>
<li><p>查看当前ss服务器所开放的端口</p>
 <figure class="highlight plain"><figcaption><span>-lntp | grep ssserver```</span></figcaption><table><tr><td class="code"><pre><span class="line">2. 查看当前ss服务器的密码，通过以下命令可见ss的配置文件，配置文件中自然有密码</span><br><span class="line">    ```ps aux | grep ssserver</span><br></pre></td></tr></table></figure>
</li>
<li><p>用cat查看下配置文件即可看见密码了</p>
 <figure class="highlight plain"><figcaption><span>/etc/shadowsocks.json```</span></figcaption><table><tr><td class="code"><pre><span class="line">4. 修改ss密码</span><br><span class="line">    ```vi /etc/shadowsocks.json</span><br></pre></td></tr></table></figure>
</li>
<li><p>按i键进入编辑模式，修改密码为123456</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6. 然后按ESC，再输入:wq保存退出</span><br><span class="line">7.  重启ss即可</span><br><span class="line">    ```service shadowsocks restart</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>附：ss启动停止方法<br><strong>启动</strong>：<figure class="highlight plain"><figcaption><span>shadowsocks start```</span></figcaption><table><tr><td class="code"><pre><span class="line">**停止**：```service shadowsocks stop</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>重启</strong>：<figure class="highlight plain"><figcaption><span>shadowsocks restart```</span></figcaption><table><tr><td class="code"><pre><span class="line">**状态**：```service shadowsocks status</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>VPN</category>
      </categories>
      <tags>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Struction-Map</title>
    <url>/2019/02/26/Data-Struction-Map/</url>
    <content><![CDATA[<h1 id="内部实现机理"><a href="#内部实现机理" class="headerlink" title="内部实现机理"></a>内部实现机理</h1><ul>
<li>map： map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。</li>
<li>unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的</li>
</ul>
<h2 id="leetcode提交代码效率对比"><a href="#leetcode提交代码效率对比" class="headerlink" title="leetcode提交代码效率对比"></a>leetcode提交代码效率对比</h2><p><a href="https://leetcode-cn.com/problems/roman-to-integer/description/" title="罗马数字转整数" target="_blank" rel="noopener">[13] 罗马数字转整数</a> </p>
<h3 id="map实现"><a href="#map实现" class="headerlink" title="map实现"></a>map实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="built_in">map</span>[<span class="string">'I'</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">map</span>[<span class="string">'V'</span>] = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">map</span>[<span class="string">'X'</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">map</span>[<span class="string">'L'</span>] = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">map</span>[<span class="string">'C'</span>] = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">map</span>[<span class="string">'D'</span>] = <span class="number">500</span>;</span><br><span class="line">    <span class="built_in">map</span>[<span class="string">'M'</span>] = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>[s[i]] &lt; <span class="built_in">map</span>[s[i+<span class="number">1</span>]])&#123;</span><br><span class="line">            sum = sum + <span class="built_in">map</span>[s[i+<span class="number">1</span>]] - <span class="built_in">map</span>[s[i]];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum += <span class="built_in">map</span>[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>.clear();</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Runtime: 40 ms, faster than 98.36% of C++ online submissions for Roman to Integer.</span><br><span class="line">Memory Usage: 11.4 MB, less than 97.68% of C++ online submissions for Roman to Integer.</span><br></pre></td></tr></table></figure>
<h3 id="unorder-map实现"><a href="#unorder-map实现" class="headerlink" title="unorder_map实现"></a>unorder_map实现</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; umap = &#123;</span><br><span class="line">    &#123;<span class="string">'I'</span>,<span class="number">1</span>&#125;,&#123;<span class="string">'V'</span>,<span class="number">5</span>&#125;,&#123;<span class="string">'X'</span>,<span class="number">10</span>&#125;,&#123;<span class="string">'L'</span>,<span class="number">50</span>&#125;,&#123;<span class="string">'C'</span>,<span class="number">100</span>&#125;,&#123;<span class="string">'D'</span>,<span class="number">500</span>&#125;,&#123;<span class="string">'M'</span>,<span class="number">1000</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (umap[s[i]] &lt; umap[s[i+<span class="number">1</span>]])&#123;</span><br><span class="line">                sum = sum + umap[s[i+<span class="number">1</span>]] - umap[s[i]];</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum += umap[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="评估-1"><a href="#评估-1" class="headerlink" title="评估"></a>评估</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Runtime: 28 ms, faster than 100.00% of C++ online submissions for Roman to Integer.</span><br><span class="line">Memory Usage: 8.7 MB, less than 98.55% of C++ online submissions for Roman to Integer.</span><br></pre></td></tr></table></figure>
<h1 id="总结优缺点以及适用处"><a href="#总结优缺点以及适用处" class="headerlink" title="总结优缺点以及适用处"></a>总结优缺点以及适用处</h1><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作；</li>
<li>红黑树，内部实现一个红黑书使得map的很多操作在lgnlgn的时间复杂度下就可以实现，因此效率非常的高；<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3></li>
<li>空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间；</li>
<li>适用处，对于那些有顺序要求的问题，用map会更高效一些；<h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3></li>
<li>因为内部实现了哈希表，因此其查找速度非常的快；<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3></li>
<li>哈希表的建立比较耗费时间；</li>
<li>适用处，对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的STL算法</title>
    <url>/2019/02/25/STL-%E5%B8%B8%E8%A7%81alg/</url>
    <content><![CDATA[<h1 id="min-a-b-和max（a-b）"><a href="#min-a-b-和max（a-b）" class="headerlink" title="min(a,b)和max（a,b）"></a>min(a,b)和max（a,b）</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(<span class="number">9</span>,<span class="number">4</span>) &lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//9</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; min(<span class="number">9</span>,<span class="number">4</span>) &lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="sort快排"><a href="#sort快排" class="headerlink" title="sort快排"></a>sort快排</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;   //注意包含algorithm头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">11</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(arr) / <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//快速排序</span></span><br><span class="line">    <span class="comment">//sort的排序范围是[start, end)，默认使用从小到大排序。</span></span><br><span class="line">    sort(arr, arr + <span class="number">3</span>);   <span class="comment">//只排序前3个</span></span><br><span class="line">    sort(arr + <span class="number">2</span>, arr + length); <span class="comment">//排序第2个元素之后的元素。</span></span><br><span class="line">    sort(arr, arr + length); <span class="comment">//排序整个数组</span></span><br><span class="line">    sort(arr, arr + length, greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">//从大到小排序整个数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="binary-search二分查找"><a href="#binary-search二分查找" class="headerlink" title="binary_search二分查找"></a>binary_search二分查找</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">24</span>,<span class="number">27</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(arr) <span class="comment">// 4;</span></span><br><span class="line"><span class="keyword">bool</span> isFind = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">isFind = binary_search(arr + <span class="number">2</span>, arr + length, <span class="number">19</span>); <span class="comment">//在[start, end)中进行二分查找key</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; isFind &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h1 id="vector（数组）"><a href="#vector（数组）" class="headerlink" title="vector（数组）"></a>vector（数组）</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator begin = v.begin(); begin != v.end(); begin++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *begin &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"isEmpty："</span> &lt;&lt; v.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    v.push_back(<span class="number">9</span>);   <span class="comment">//在数组的最后添加一个元素</span></span><br><span class="line">    v.push_back(<span class="number">12</span>);</span><br><span class="line">    v.push_back(<span class="number">15</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Size："</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line">    v.pop_back();   <span class="comment">//删除最后一个元素</span></span><br><span class="line">    printVector(v); <span class="comment">//输出 9 12</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"v[1] = "</span> &lt;&lt; v.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// v[1] = 12</span></span><br><span class="line"> </span><br><span class="line">    v.insert(v.begin() + <span class="number">1</span>, <span class="number">99</span>);  <span class="comment">// 在第v[1]位置插入99元素</span></span><br><span class="line">    v.insert(v.begin() + <span class="number">1</span>, <span class="number">5</span>, <span class="number">88</span>); <span class="comment">//从v[1]开始，插入5个88</span></span><br><span class="line">    printVector(v);  <span class="comment">//9 88 88 88 88 88 99 12</span></span><br><span class="line"> </span><br><span class="line">    v.erase(v.begin()); <span class="comment">//删除第i个数</span></span><br><span class="line">    printVector(v); <span class="comment">//88 88 88 88 88 99 12</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"first："</span> &lt;&lt; v.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="stack（栈）"><a href="#stack（栈）" class="headerlink" title="stack（栈）"></a>stack（栈）</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;   //注意包含stack头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">//声明stack中的类型，以及栈名称</span></span><br><span class="line">    s.push(<span class="number">3</span>);</span><br><span class="line">    s.push(<span class="number">4</span>);    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">int</span> length = s.size(); <span class="comment">//获取栈元素数量</span></span><br><span class="line">    <span class="keyword">int</span> top = s.top();    <span class="comment">//获取栈顶元素（不出栈）</span></span><br><span class="line">    s.pop();    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">bool</span> isEmpty = s.empty();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="queue（普通队列）"><a href="#queue（普通队列）" class="headerlink" title="queue（普通队列）"></a>queue（普通队列）</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;   //注意包含queue头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    q.push(<span class="string">"hello"</span>);  <span class="comment">//入队</span></span><br><span class="line">    q.push(<span class="string">"world"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; q.front() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//hello 获取队首元素值，但是不出队</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; q.back() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//world 获取队尾元素值，但是不出队</span></span><br><span class="line"> </span><br><span class="line">    q.pop();   <span class="comment">//队首元素出队</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; q.front() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//world</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"size "</span> &lt;&lt; q.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"isEmpty "</span> &lt;&lt; q.empty() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="deque（双向队列）"><a href="#deque（双向队列）" class="headerlink" title="deque（双向队列）"></a>deque（双向队列）</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; &amp; dq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator begin = dq.begin(); begin != dq.end(); begin++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *begin &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">    dq.push_back(<span class="number">5</span>);</span><br><span class="line">    dq.push_back(<span class="number">6</span>);</span><br><span class="line">    dq.push_front(<span class="number">8</span>);</span><br><span class="line">    dq.push_front(<span class="number">7</span>);</span><br><span class="line">    printDeque(dq);  <span class="comment">//7 8 5 6</span></span><br><span class="line"> </span><br><span class="line">    dq.pop_back();</span><br><span class="line">    dq.pop_front();</span><br><span class="line">    printDeque(dq);  <span class="comment">// 8 5</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dq.front() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dq.back() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 5</span></span><br><span class="line"> </span><br><span class="line">    dq.insert(dq.begin() + <span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">    printDeque(dq); <span class="comment">//8 9 5</span></span><br><span class="line"> </span><br><span class="line">    dq.insert(dq.begin(), <span class="number">5</span>, <span class="number">88</span>);</span><br><span class="line">    printDeque(dq); <span class="comment">// 88 88 88 88 88 8 9 5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size："</span> &lt;&lt; dq.size() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="list（双向链表）"><a href="#list（双向链表）" class="headerlink" title="list（双向链表）"></a>list（双向链表）</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l)</span></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator p;</span><br><span class="line">    <span class="keyword">for</span> (p = l.begin(); p != l.end(); p++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l;</span><br><span class="line">    l.push_front(<span class="number">6</span>);  <span class="comment">//从左边入队</span></span><br><span class="line">    l.push_front(<span class="number">7</span>);</span><br><span class="line">    l.push_back(<span class="number">8</span>);   <span class="comment">//从右边入队</span></span><br><span class="line">    printList(l);  <span class="comment">//7 6 8</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; l.front() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//7 返回左边第一个元素的值（不删除元素）</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; l.back() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 8 返回有边第一个元素的值（不删除元素）</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; l.size() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//返回元素的总个数</span></span><br><span class="line"> </span><br><span class="line">    l.reverse();  <span class="comment">//进行翻转</span></span><br><span class="line">    printList(l);    <span class="comment">//8 6 7</span></span><br><span class="line"> </span><br><span class="line">    l.pop_front(); <span class="comment">//删除左边第一个元素</span></span><br><span class="line">    l.pop_back();  <span class="comment">//删除右边第一个元素</span></span><br><span class="line">    printList(l);  <span class="comment">//6</span></span><br><span class="line"> </span><br><span class="line">    l.push_back(<span class="number">6</span>);</span><br><span class="line">    printList(l);  <span class="comment">//6 6</span></span><br><span class="line">    l.remove(<span class="number">6</span>);   <span class="comment">//删除值为6的所有元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; l.empty() &lt;&lt; l.size() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//1 0</span></span><br><span class="line"> </span><br><span class="line">    l.push_back(<span class="number">4</span>);</span><br><span class="line">    l.push_back(<span class="number">1</span>);</span><br><span class="line">    l.push_back(<span class="number">3</span>);</span><br><span class="line">    l.sort();   <span class="comment">//排序</span></span><br><span class="line">    printList(l);   <span class="comment">//1 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="set-multiset（集合）"><a href="#set-multiset（集合）" class="headerlink" title="set/multiset（集合）"></a>set/multiset（集合）</h1><p>multiset/set使用平衡二叉树的数据结构，插入和查找时间复杂度都是log n。<br>multiset和set的用法相同，只有一个区别：</p>
<ol>
<li>multiset中可以出现重复的元素。</li>
<li>set中不会出现重复的元素，即使添加重复的元素，也会自动去重。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;   //multiset和set都要包含set头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">8</span>&#125;;<span class="comment">//有重复的元素</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms; <span class="comment">//创建一个空格multiset集合</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ms.insert(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator p;  <span class="comment">//声明一个迭代器，类似于指针</span></span><br><span class="line">    <span class="keyword">for</span> (p = ms.begin(); p != ms.end(); p++) &#123;</span><br><span class="line">        <span class="comment">//ms.begin()  返回一个迭代器，指向multiset的第一个元素</span></span><br><span class="line">        <span class="comment">//ms.end()   返回一个迭代器，指向multiset最后一个元素的后面一个位置</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span>;    <span class="comment">//1 2 3 4 4 5 5 6 8 8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> length = ms.size();   <span class="comment">//集合中元素的数量</span></span><br><span class="line">    <span class="keyword">bool</span> isEmpty = ms.empty();  <span class="comment">// 集合是否为空</span></span><br><span class="line">    <span class="keyword">int</span> cnt = ms.count(<span class="number">8</span>);   <span class="comment">//计算一个数出现的次数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; length &lt;&lt; <span class="string">" "</span> &lt;&lt; isEmpty &lt;&lt; <span class="string">" "</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 10  0   2</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//查找元素，如果找到的话，返回一个迭代器指向找到的元素。如果没有找到的话，就返回multiset中元素总个数size</span></span><br><span class="line">    p = ms.find(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (*p != ms.size()) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"found "</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//8</span></span><br><span class="line">        ms.erase(*p);   <span class="comment">//删除集合中所有的8，不是只删除一个。</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"after delete , the size is "</span>&lt;&lt; ms.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"not found"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>　</p>
<h1 id="map-multimap（映射、字典）"><a href="#map-multimap（映射、字典）" class="headerlink" title="map/multimap（映射、字典）"></a>map/multimap（映射、字典）</h1><p>map和multimap的都是使用hash算法。<br><strong>区别在于，map中的key只能出现一次，而multimap可以出现很多次。</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;   //multimap和map都要包含set头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line">    m[<span class="string">"one"</span>] = <span class="string">"hello"</span>;</span><br><span class="line">    m[<span class="string">"two"</span>] = <span class="string">"world"</span>;</span><br><span class="line">    m.insert(pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">"three"</span>, <span class="string">"C++"</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">bool</span> isEmpty = m.empty();</span><br><span class="line">    <span class="keyword">int</span> length = m.size();</span><br><span class="line">    <span class="built_in">string</span> s = m[<span class="string">"one"</span>];  <span class="comment">//找到的话，就返回对应的值</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; s &lt;&lt;<span class="built_in">endl</span>;   <span class="comment">// hello</span></span><br><span class="line">    s = m[<span class="string">"four"</span>];    <span class="comment">//未找到的话，就返回一个类型零值</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; s &lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//返回空字符串</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator p;</span><br><span class="line">    p = m.find(<span class="string">"one"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; p-&gt;second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出one对应的值--&gt; hello</span></span><br><span class="line"> </span><br><span class="line">    m.erase(p);  <span class="comment">//删除某个key</span></span><br><span class="line">    <span class="keyword">for</span> (p = m.begin(); p != m.end(); p++) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; p-&gt;second &lt;&lt; <span class="string">" "</span>;  <span class="comment">// C++ world</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    m.clear(); <span class="comment">//清空map</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Struction-Iterator</title>
    <url>/2019/02/20/Data-Struction-Iterator/</url>
    <content><![CDATA[<p>在遍历vector、list等容器时使用最多的就是迭代器，以下对迭代器做一总结：</p>
<ul>
<li>迭代器按照定义方式分成以下四种。<ol>
<li>正向迭代器，定义方法如下：<br><code>容器类名::iterator  迭代器名;</code></li>
<li>常量正向迭代器，定义方法如下：<br><code>容器类名::const_iterator  迭代器名;</code></li>
<li>反向迭代器，定义方法如下：<br><code>容器类名::reverse_iterator  迭代器名;</code></li>
<li>常量反向迭代器，定义方法如下：<br><code>容器类名::const_reverse_iterator  迭代器名;</code></li>
</ol>
</li>
</ul>
<h1 id="迭代器用法示例"><a href="#迭代器用法示例" class="headerlink" title="迭代器用法示例"></a>迭代器用法示例</h1><p>通过迭代器可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。</p>
<ul>
<li>迭代器都可以进行<code>++</code>操作。反向迭代器和正向迭代器的区别在于：<ol>
<li>对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；</li>
<li>而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素。</li>
</ol>
</li>
</ul>
<p>下面的程序演示了如何通过迭代器遍历一个 vector 容器中的所有元素:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;  <span class="comment">//v是存放int类型变量的可变长数组，开始时没有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n&lt;<span class="number">5</span>; ++n)</span><br><span class="line">        v.push_back(n);  <span class="comment">//push_back成员函数在vector容器尾部添加一个元素</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;  <span class="comment">//定义正向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.begin(); i != v.end(); ++i) &#123;  <span class="comment">//用迭代器遍历容器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;  <span class="comment">//*i 就是迭代器i指向的元素</span></span><br><span class="line">        *i *= <span class="number">2</span>;  <span class="comment">//每个元素变为原来的2倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//用反向迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator j = v.rbegin(); j != v.rend(); ++j)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *j &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4</span><br><span class="line">8 6 4 2 0</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong><br>第 6 行，vector 容器有多个构造函数，如果用无参构造函数初始化，则容器一开始是空的。</p>
<p>第 10 行，<code>begin</code> 成员函数返回指向容器中第一个元素的迭代器。<code>++i</code> 使得 i 指向容器中的下一个元素。<code>end</code> 成员函数返回的不是指向最后一个元素的迭代器，而是指向最后一个元素后面的位置的迭代器，因此循环的终止条件是<code>i != v.end()</code>。</p>
<p>第 16 行定义了反向迭代器用以遍历容器。反向迭代器进行++操作后，会指向容器中的上一个元素。<code>rbegin</code> 成员函数返回指向容器中最后一个元素的迭代器，<code>rend</code> 成员函数返回指向容器中第一个元素前面的位置的迭代器，因此本循环实际上是从后往前遍历整个数组。</p>
<p>如果迭代器指向了容器中最后一个元素的后面或第一个元素的前面，再通过该迭代器访问元素，就有可能导致程序崩溃，这和访问 NULL 或未初始化的指针指向的地方类似。</p>
<p>第 10 行和第 16 行，写<code>++i、++j</code>相比于写<code>i++、j++</code>，程序的执行速度更快。回顾++被重载成前置和后置运算符的例子如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CDemo CDemo::<span class="keyword">operator</span>++ ()</span><br><span class="line">&#123;  <span class="comment">//前置++</span></span><br><span class="line">    ++n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">CDemo CDemo::<span class="keyword">operator</span> ++(<span class="keyword">int</span> k)</span><br><span class="line">&#123;  <span class="comment">//后置++</span></span><br><span class="line">    <span class="function">CDemo <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;  <span class="comment">//记录修改前的对象</span></span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> tmp;  <span class="comment">//返回修改前的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后置<code>++</code>要多生成一个局部对象 <code>tmp</code>，因此执行速度比前置的慢。同理，迭代器是一个对象，STL 在重载迭代器的<code>++运算符</code>时，后置形式也比前置形式慢。在次数很多的循环中，<code>++i</code>和<code>i++</code>可能就会造成运行时间上可观的差别了。因此，本教程在前面特别提到，对循环控制变量i，要养成写<code>++i</code>、不写<code>i++</code>的习惯。</p>
<p>注意，容器适配器 <code>stack</code>、<code>queue</code> 和 <code>priority_queue</code> 没有迭代器。容器适配器有一些成员函数，可以用来对元素进行访问。</p>
<h2 id="迭代器的功能分类"><a href="#迭代器的功能分类" class="headerlink" title="迭代器的功能分类"></a>迭代器的功能分类</h2><p>不同容器的迭代器，其功能强弱有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。例如，排序算法需要通过随机访问迭代器来访问容器中的元素，因此有的容器就不支持排序算法。</p>
<p>常用的迭代器按功能强弱分为输入、输出、正向、双向、随机访问五种，这里只介绍常用的三种。</p>
<p>1) 正向迭代器。假设 p 是一个正向迭代器，则 p 支持以下操作：<code>++p，p++，*p</code>。此外，两个正向迭代器可以互相赋值，还可以用==和!=运算符进行比较。</p>
<p>2) 双向迭代器。双向迭代器具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则<code>--p</code>和<code>p--</code>都是有定义的。<code>--p</code>使得 p 朝和<code>++p</code>相反的方向移动。</p>
<p>3) 随机访问迭代器。随机访问迭代器具有双向迭代器的全部功能。若 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：<br><code>p+=i</code>：使得 p 往后移动 i 个元素。<br><code>p-=i</code>：使得 p 往前移动 i 个元素。<br><code>p+i</code>：返回 p 后面第 i 个元素的迭代器。<br><code>p-i</code>：返回 p 前面第 i 个元素的迭代器。<br><code>p[i]</code>：返回 p 后面第 i 个元素的引用。</p>
<p>此外，两个随机访问迭代器 p1、p2 还可以用<code>&lt;、&gt;、&lt;=、&gt;=</code>运算符进行比较。<code>p1&lt;p2</code>的含义是：p1 经过若干次（至少一次）++操作后，就会等于 p2。其他比较方式的含义与此类似。</p>
<p>对于两个随机访问迭代器 p1、p2，表达式<code>p2-p1</code>也是有定义的，其返回值是 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。</p>
<ul>
<li>表1所示为不同容器的迭代器的功能。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>容器</th>
<th style="text-align:center">迭代器功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector</td>
<td style="text-align:center">随机访问</td>
</tr>
<tr>
<td>deque</td>
<td style="text-align:center">随机访问</td>
</tr>
<tr>
<td>list</td>
<td style="text-align:center">双向</td>
</tr>
<tr>
<td>set / multiset</td>
<td style="text-align:center">双向</td>
</tr>
<tr>
<td>map / multimap</td>
<td style="text-align:center">双向</td>
</tr>
<tr>
<td>stack</td>
<td style="text-align:center">不支持迭代器</td>
</tr>
<tr>
<td>queue</td>
<td style="text-align:center">不支持迭代器</td>
</tr>
<tr>
<td>priority_queue</td>
<td style="text-align:center">不支持迭代器</td>
</tr>
</tbody>
</table>
</div>
<p>表1：不同容器的迭代器的功能</p>
<p>例如，<code>vector</code> 的迭代器是随机迭代器，因此遍历 <code>vector</code> 容器有以下几种做法。下面的程序中，每个循环演示了一种做法。</p>
<p>【实例】遍历 vector 容器。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; v(100); //v被初始化成有100个元素</span><br><span class="line">    for(int i = 0;i &lt; v.size() ; ++i) //size返回元素个数</span><br><span class="line">        cout &lt;&lt; v[i]; //像普通数组一样使用vector容器</span><br><span class="line">    vector&lt;int&gt;::iterator i;</span><br><span class="line">    for(i = v.begin(); i != v.end (); ++i) //用 != 比较两个迭代器</span><br><span class="line">        cout &lt;&lt; * i;</span><br><span class="line">    for(i = v.begin(); i &lt; v.end ();++i) //用 &lt; 比较两个迭代器</span><br><span class="line">        cout &lt;&lt; * i;</span><br><span class="line">    i = v.begin();</span><br><span class="line">    while(i &lt; v.end()) &#123; //间隔一个输出</span><br><span class="line">        cout &lt;&lt; * i;</span><br><span class="line">        i += 2; // 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>list</code> 容器的迭代器是双向迭代器。假设 <code>v</code> 和 <code>i</code> 的定义如下：<br>纯文本复制<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list&lt;int&gt; v;</span><br><span class="line">list&lt;int&gt;::const_iterator i;</span><br></pre></td></tr></table></figure></p>
<p>则以下代码是合法的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(i=v.begin(); i!=v.end(); ++i)</span><br><span class="line">cout &lt;&lt; *i;</span><br></pre></td></tr></table></figure></p>
<p>以下代码则不合法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(i=v.begin(); i&lt;v.end(); ++i)</span><br><span class="line">cout &lt;&lt; *i;</span><br></pre></td></tr></table></figure></p>
<p>因为双向迭代器不支持用“&lt;”进行比较。以下代码也不合法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i=0; i&lt;v.size(); ++i)</span><br><span class="line">cout &lt;&lt; v[i];</span><br></pre></td></tr></table></figure></p>
<p>因为 list 不支持随机访问迭代器的容器，也不支持用下标随机访问其元素。</p>
<p>在 C++ 中，数组也是容器。数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组 <code>int a[10]，int *</code> 类型的指针就是其迭代器。则 a、a+1、a+2 都是 a 的迭代器。<br>迭代器的辅助函数</p>
<h2 id="STL-中有用于操作迭代器的三个函数模板，它们是："><a href="#STL-中有用于操作迭代器的三个函数模板，它们是：" class="headerlink" title="STL 中有用于操作迭代器的三个函数模板，它们是："></a>STL 中有用于操作迭代器的三个函数模板，它们是：</h2><p><code>advance(p, n)</code>：使迭代器 p 向前或向后移动 n 个元素。<br><code>distance(p, q)</code>：计算两个迭代器之间的距离，即迭代器 p 经过多少次 + + 操作后和迭代器 q 相等。如果调用时 p 已经指向 q 的后面，则这个函数会陷入死循环。<br><code>iter_swap(p, q)</code>：用于交换两个迭代器 p、q 指向的值。</p>
<p>要使用上述模板，需要包含头文件 <code>algorithm</code>。下面的程序演示了这三个函数模板的 用法。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //要使用操作迭代器的函数模板，需要包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; lst(a, a+<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt;::iterator p = lst.begin();</span><br><span class="line">    advance(p, <span class="number">2</span>);  <span class="comment">//p向后移动两个元素，指向3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1)"</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 1)3</span></span><br><span class="line">    advance(p, <span class="number">-1</span>);  <span class="comment">//p向前移动一个元素，指向2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2)"</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 2)2</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator q = lst.end();</span><br><span class="line">    q--;  <span class="comment">//q 指向 5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3)"</span> &lt;&lt; distance(p, q) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 3)3</span></span><br><span class="line">    iter_swap(p, q); <span class="comment">//交换 2 和 5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4)"</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = lst.begin(); p != lst.end(); ++p)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序的输出结果是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1 5 3 4 2</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Struction-Vector</title>
    <url>/2019/02/20/Data-Struction-Vector/</url>
    <content><![CDATA[<h1 id="底层数据结构为数组-，支持快速随机访问"><a href="#底层数据结构为数组-，支持快速随机访问" class="headerlink" title="底层数据结构为数组 ，支持快速随机访问"></a>底层数据结构为数组 ，支持快速随机访问</h1><p>vector和built-in数组类似，它拥有一段连续的内存空间，并且起始地址不变，因此它能非常好的支持随机存取，即[]操作符，但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝，另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。这些都大大影响了vector的效率。（中间插入和删除效率低）.它采用线性空间存储数据。如果空间不够，则另外分配新的两倍大小的空间，然后把旧空间释放掉。</p>
<ul>
<li>vector不适合push_front(效率很低)</li>
<li>vector不适合中间插入删除操作。中间插入删除操作会引起内存拷贝。</li>
</ul>
<h1 id="存放结构体类型的变量的两种存放方式"><a href="#存放结构体类型的变量的两种存放方式" class="headerlink" title="存放结构体类型的变量的两种存放方式"></a>存放结构体类型的变量的两种存放方式</h1><ul>
<li>方式一：放入这个结构体类型变量的副本。</li>
<li>方式二：放入指向这个结构体类型变量的指针。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*[方式一] 结构体放栈中,vector中放副本---------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span> school_name[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">char</span> gender;</span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">bool</span> is_absent;</span><br><span class="line">&#125; StudentInfo;</span><br><span class="line"> </span><br><span class="line">typedefstd::<span class="built_in">vector</span>&lt;StudentInfo&gt; StudentInfoVec;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(StudentInfoVec* stduentinfovec)</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(*stduentinfovec).size();j++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;</span><br><span class="line">           (*stduentinfovec)[j].school_name&lt;&lt;<span class="string">"\t"</span>&lt;&lt;</span><br><span class="line">           (*stduentinfovec)[j].gender&lt;&lt;<span class="string">"\t"</span>&lt;&lt;</span><br><span class="line">           (*stduentinfovec)[j].age&lt;&lt;<span class="string">"\t"</span>&lt;&lt;</span><br><span class="line">           (*stduentinfovec)[j].is_absent&lt;&lt;<span class="string">"\t"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   StudentInfo micheal=&#123;<span class="string">"Micheal"</span>,<span class="string">'m'</span>,<span class="number">18</span>,<span class="literal">false</span>&#125;;</span><br><span class="line">   StudentInfo cherry=&#123;<span class="string">"Cherry"</span>,<span class="string">'f'</span>,<span class="number">16</span>,<span class="literal">true</span>&#125;;</span><br><span class="line">   StudentInfoVec studentinfovec;</span><br><span class="line">   studentinfovec.push_back(micheal);</span><br><span class="line">   studentinfovec.push_back(cherry);</span><br><span class="line">   print(&amp;studentinfovec);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*[方式二]  结构体放入堆中，vector中放指针---------------------*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span>* school_name;</span><br><span class="line">   <span class="keyword">char</span> gender;</span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">bool</span> is_absent;</span><br><span class="line">&#125; StudentInfo;</span><br><span class="line"> </span><br><span class="line">typedefstd::<span class="built_in">vector</span>&lt;StudentInfo*&gt; StudentInfoPtrVec;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(StudentInfoPtrVec*stduentinfoptrvec)</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(*stduentinfoptrvec).size();j++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;</span><br><span class="line">           (*stduentinfoptrvec)[j]-&gt;school_name&lt;&lt;<span class="string">"\t"</span>&lt;&lt;</span><br><span class="line">           (*stduentinfoptrvec)[j]-&gt;gender&lt;&lt;<span class="string">"\t"</span>&lt;&lt;</span><br><span class="line">           (*stduentinfoptrvec)[j]-&gt;age&lt;&lt;<span class="string">"\t"</span>&lt;&lt;</span><br><span class="line">           (*stduentinfoptrvec)[j]-&gt;is_absent&lt;&lt;<span class="string">"\t"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   StudentInfoPtrVec studentinfoptrvec;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">char</span>* p_char_1=<span class="literal">NULL</span>;</span><br><span class="line">   p_char_1=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">   <span class="built_in">strcpy</span>(p_char_1,<span class="string">"Micheal"</span>);</span><br><span class="line">   StudentInfo* p_student_1=<span class="keyword">new</span> StudentInfo;</span><br><span class="line">   p_student_1-&gt;school_name=p_char_1;</span><br><span class="line">   p_student_1-&gt;gender=<span class="string">'m'</span>;</span><br><span class="line">   p_student_1-&gt;age=<span class="number">18</span>;</span><br><span class="line">   p_student_1-&gt;is_absent=<span class="literal">false</span>;</span><br><span class="line">   studentinfoptrvec.push_back(p_student_1);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">char</span>* p_char_2=<span class="literal">NULL</span>;</span><br><span class="line">   p_char_2=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">   <span class="built_in">strcpy</span>(p_char_2,<span class="string">"Cherry"</span>);</span><br><span class="line">   StudentInfo* p_student_2=<span class="keyword">new</span> StudentInfo;</span><br><span class="line">    p_student_2-&gt;school_name=p_char_2;</span><br><span class="line">   p_student_2-&gt;gender=<span class="string">'f'</span>;</span><br><span class="line">   p_student_2-&gt;age=<span class="number">16</span>;</span><br><span class="line">   p_student_2-&gt;is_absent=<span class="literal">false</span>;</span><br><span class="line">   studentinfoptrvec.push_back(p_student_2);</span><br><span class="line">      </span><br><span class="line">   print(&amp;studentinfoptrvec);</span><br><span class="line">   <span class="keyword">delete</span> p_char_1;</span><br><span class="line">   <span class="keyword">delete</span> p_student_1;</span><br><span class="line">   <span class="keyword">delete</span> p_char_2;</span><br><span class="line">   <span class="keyword">delete</span> p_student_2;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Struction-List</title>
    <url>/2019/02/15/Data-Struction-List/</url>
    <content><![CDATA[<h1 id="List：双向链表"><a href="#List：双向链表" class="headerlink" title="List：双向链表"></a>List：双向链表</h1><p> list就是双向链表,元素也是在堆中存放,每个元素都是放在一块内存中,它的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随机存取变的非常没有效率，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。</p>
<p> list没有空间预留习惯,所以每分配一个元素都会从内存中分配,每删除一个元素都会释放它占用的内存.</p>
<p> list在哪里添加删除元素性能都很高,不需要移动内存,当然也不需要对每个元素都进行构造与析构了,所以常用来做随机操作容器.<br> 但是访问list里面的元素时就开始和最后访问最快<br> 访问其它元素都是O(n) ,所以如果需要经常随机访问的话,还是使用其它的好</p>
<p><strong><em>总结</em></strong><br> 如果你喜欢经常添加删除大对象的话,那么请使用list<br> 要保存的对象不大,构造与析构操作不复杂,那么可以使用vector代替<br> list&lt;指针&gt;完全是性能最低的做法,这种情况下还是使用vector&lt;指针&gt;好,因为指针没有构造与析构,也不占用很大内存.</p>
<hr>
<p>1.vector      底层数据结构为数组 ，支持快速随机访问</p>
<p>2.list            底层数据结构为双向链表，支持快速增删</p>
<p>3.deque       底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问<br>deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:<br>[堆1] —&gt; [堆2] —&gt;[堆3] —&gt; …<br>每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.</p>
<p>4.stack        底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</p>
<p>5.queue     底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</p>
<p>（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）</p>
<p>6.priority_queue     的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</p>
<p>7.set                   底层数据结构为红黑树，有序，不重复</p>
<p>8.multiset         底层数据结构为红黑树，有序，可重复 </p>
<p>9.map                底层数据结构为红黑树，有序，不重复</p>
<p>10.multimap    底层数据结构为红黑树，有序，可重复</p>
<p>11.hash_set     底层数据结构为hash表，无序，不重复</p>
<p>12.hash_multiset 底层数据结构为hash表，无序，可重复 </p>
<p>13.hash_map    底层数据结构为hash表，无序，不重复</p>
<p>14.hash_multimap 底层数据结构为hash表，无序，可重复 </p>
<p>迭代器模式的定义是：设计一种方法，使得依据某种顺序遍历容器时，容器内部的具体结构是不可见的。C++ STL中，迭代器的本质就是指针，但是这个指针在不同场合是有区别的：</p>
<ul>
<li><p>对vector::iterator而言，迭代器是指向vector某元素的指针，和T a*差不多；对于list和slist而言，迭代器指向链表节点；对map和set等基于二叉搜索树的容器而言，迭代器可以看成是指向treenode的指针。因此STL迭代器大致可分为两种，一种是连续地址空间的，一种是非连续地址空间的。然而不管是哪一种，在遍历过程中修改容器的内容绝对是大忌中的大忌！</p>
</li>
<li><p>对vector而言，插入删除操作往往包含着malloc、realloc操作，一旦空间重塑了，原来的迭代器也将失效，如再理所应当地it++，你的it就不知道跑哪里去了。</p>
</li>
<li><p>对list而言，虽然it++仅仅意味着p=p-&gt;next，但如果list的内容改变，此next还是不是彼next可就说不好了。</p>
</li>
<li><p>对于map和set，it的遍历是遵循二叉搜索树中序遍历顺序的（即有序遍历），it++找的是右子树的最左边，reverse_it++找的是左子树的最右边，随随便便插入删除，既有可能影响迭代器的遍历。 </p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>Template模式</title>
    <url>/2019/01/07/Design%20Pattern-Template/</url>
    <content><![CDATA[<h1 id="Template模式"><a href="#Template模式" class="headerlink" title="Template模式"></a>Template模式</h1><p>在面向对象系统的分析与设计过程中经常会遇到这样一种情况：对于某一个业务逻辑（算法实现）在不同的对象中有不同的细节实现，但是逻辑（算法）的框架（或通用的应用算法）是相同的。Template提供了这种情况的一个实现框架。</p>
<blockquote>
<p>Template模式是采用继承的方式实现这一点：将逻辑（算法）框架放在抽象基类中，并定义好细节的接口，子类中实现细节。</p>
</blockquote>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://oscimg.oschina.net/oscnet/ed7e0d9582d3dc02112aa02277c7113b723.jpg" alt="template method" title="template method"></p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="https://oscimg.oschina.net/oscnet/09807c2bb040f2aa3af7efbf88b73102712.jpg" alt=""></p>
<h3 id="结构化软件开发设计流程（template1）：App调用Lib"><a href="#结构化软件开发设计流程（template1）：App调用Lib" class="headerlink" title="结构化软件开发设计流程（template1）：App调用Lib"></a>结构化软件开发设计流程（template1）：App调用Lib</h3><ul>
<li><h3 id="Library开发："><a href="#Library开发：" class="headerlink" title="Library开发："></a>Library开发：</h3></li>
</ul>
<ol>
<li>开发1、3、5三个步骤<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//库开发</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Library</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Step1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Step3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Step5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><h3 id="Application开发："><a href="#Application开发：" class="headerlink" title="Application开发："></a>Application开发：</h3></li>
</ul>
<ol>
<li>开发2、4两个步骤；</li>
<li>程序主流程<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//应用开发</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Step4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Library <span class="title">lib</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Application <span class="title">app</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	lib.Step1();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (app.Step2()) &#123;</span><br><span class="line">		lib.Step3();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		app.Step4();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lib.Step5();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="面向对象软设计流程（template2）：Lib调用App"><a href="#面向对象软设计流程（template2）：Lib调用App" class="headerlink" title="面向对象软设计流程（template2）：Lib调用App"></a>面向对象软设计流程（template2）：Lib调用App</h3><ul>
<li><h3 id="Library开发：-1"><a href="#Library开发：-1" class="headerlink" title="Library开发："></a>Library开发：</h3></li>
</ul>
<ol>
<li>开发1、3、5三个步骤</li>
<li>程序主流程<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//库开发</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Library</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//稳定 template method</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Step1();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Step2()) &#123; <span class="comment">//支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class="line">			Step3();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			Step4(); <span class="comment">//支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Step5();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~Library() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Step1</span><span class="params">()</span> </span>&#123;<span class="comment">//稳定</span></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Step3</span><span class="params">()</span> </span>&#123;<span class="comment">//稳定</span></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Step5</span><span class="params">()</span> </span>&#123;<span class="comment">//稳定</span></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//变化</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Step4</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//变化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><h3 id="Application开发：-1"><a href="#Application开发：-1" class="headerlink" title="Application开发："></a>Application开发：</h3></li>
</ul>
<ol>
<li>开发2、4两个步骤<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//应用开发</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> :</span> <span class="keyword">public</span> Library&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">bool</span> Step2（）&#123;</span><br><span class="line">		<span class="comment">//...子类重写实现</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">bool</span> Step4（）&#123;</span><br><span class="line">		<span class="comment">//...子类重写实现</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main（）</span><br><span class="line">&#123;</span><br><span class="line">	Library* pLib = <span class="keyword">new</span> Application();<span class="comment">//多态指针</span></span><br><span class="line">	lib-&gt;Run();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> pLib;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="相关代码："><a href="#相关代码：" class="headerlink" title="相关代码："></a>相关代码：</h3><p>在基类Analyse.h中只声明纯虚函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Analyse</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">uint32_t</span> dataSize)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>Analyse.cpp中Recv用于接收数据，并进行后续分析处理，但Analyse由子类自己实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Analyse::Recv(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">uint32_t</span> dataSize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_data.IsIgnoreLink())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc = Analyse(data, dataSize);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>比如SubAnlyse中在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Time Complexity</title>
    <url>/2019/01/07/algTime/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th>Name</th>
<th>Insert</th>
<th>Access</th>
<th>Search</th>
<th>Delete</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td>Array</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>Insertion to the end is O(1). Details here.</td>
</tr>
<tr>
<td>(Hash)Map</td>
<td>O(1)*</td>
<td>O(1)*</td>
<td>O(1)*</td>
<td>O(1)*</td>
<td>Rehashing might affect insertion time. Details here.</td>
</tr>
<tr>
<td>Map (using Binary Search Tree)</td>
<td>O(log(n))</td>
<td>-</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
<td>Implemented using Binary Search Tree</td>
</tr>
<tr>
<td>Set (using HashMap)</td>
<td>O(1)*</td>
<td>-</td>
<td>O(1)*</td>
<td>O(1)*</td>
<td>Set using a HashMap implementation. Details here.</td>
</tr>
<tr>
<td>Set (using list)</td>
<td>O(n)</td>
<td>-</td>
<td>O(n)]</td>
<td>O(n)</td>
<td>Implemented using Binary Search Tree</td>
</tr>
<tr>
<td>Set (using Binary Search Tree)</td>
<td>O(log(n))</td>
<td>-</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
<td>Implemented using Binary Search Tree</td>
</tr>
<tr>
<td>Linked List (singly)</td>
<td>O(n)</td>
<td>-</td>
<td>O(n)</td>
<td>O(n)</td>
<td>Adding/Removing to the start of the list is O(1). Details here.</td>
</tr>
<tr>
<td>Linked List (doubly)</td>
<td>O(n)</td>
<td>-</td>
<td>O(n)</td>
<td>O(n)</td>
<td>Adding/Deleting from the beginning/end is O(1). But, deleting/adding from the middle is O(n). Details here</td>
</tr>
<tr>
<td>Stack (array implementation)</td>
<td>O(1)</td>
<td>-</td>
<td>-</td>
<td>O(1)</td>
<td>Insert/delete is last-in, first-out (LIFO)</td>
</tr>
<tr>
<td>Queue (naive array impl.)</td>
<td>O(n)</td>
<td>-</td>
<td>-</td>
<td>O(1)</td>
<td>Insert (Array.shift) is O(n)</td>
</tr>
<tr>
<td>Queue (array implementation)</td>
<td>O(1)*</td>
<td>-</td>
<td>-</td>
<td>O(1)</td>
<td>Worst time insert is O(n). However amortized is O(1)</td>
</tr>
<tr>
<td>Queue (list implementation)</td>
<td>O(1)</td>
<td>-</td>
<td>-</td>
<td>O(1)</td>
<td>Using Doubly Linked List with reference to the last element.</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2019/01/07/algTime/algTime.png" alt=""></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World AND Markdown</title>
    <url>/2019/01/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">维基百科</a></p>
</blockquote>
<p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.example.com" target="_blank" rel="noopener">链接</a>或一个脚注<sup><a href="#fn_demo" id="reffn_demo">demo</a></sup>。下面列举了几个高级功能，更多语法请按<code>Ctrl + /</code>查看帮助。 </p>
<h3 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h3><p>可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式：</p>
<script type="math/tex; mode=display">x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a}</script><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">e=&gt;end</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>
<p>以及时序图:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
